# 软件著作权源代码提取指南

## 一、源代码要求

根据《计算机软件著作权登记办法》的要求：
- 提供源代码的前30页和后30页，共60页
- 每页50行代码
- 总计3000行代码
- 代码必须连续，不能跳跃
- 每页需要标注页码和文件路径

## 二、代码选择策略

### 前30页代码选择（展示核心功能和入口）

**目标**：展示软件的整体架构、核心功能入口和关键业务逻辑

**推荐文件顺序**：

1. **应用入口（约5页）**
   - `app/lib/main.dart` - 应用程序入口，展示初始化流程

2. **AI识别服务（约10页）**
   - `app/lib/services/ocr_service.dart` - 图片识别服务
   - `app/lib/services/voice/voice_recognition_service.dart` - 语音识别服务
   - `app/lib/services/ai_service.dart` - AI服务集成

3. **核心业务逻辑（约10页）**
   - `app/lib/services/transaction_service.dart` - 交易记账服务
   - `app/lib/services/budget_service.dart` - 预算管理服务
   - `app/lib/models/transaction.dart` - 交易数据模型

4. **智能分类算法（约5页）**
   - `app/lib/services/category_service.dart` - 分类服务
   - `app/lib/services/smart_categorization_service.dart` - 智能分类算法

### 后30页代码选择（展示创新算法和后端实现）

**目标**：展示软件的技术创新点、核心算法和后端实现

**推荐文件顺序**：

1. **零基预算算法（约8页）**
   - `app/lib/services/pocket_service.dart` - 小金库服务
   - `app/lib/services/budget_allocation_service.dart` - 预算分配算法

2. **钱龄计算引擎（约7页）**
   - `app/lib/services/money_age_service.dart` - 钱龄计算服务
   - `app/lib/models/money_age.dart` - 钱龄数据模型

3. **数据同步机制（约5页）**
   - `app/lib/services/sync_service.dart` - 数据同步服务
   - `app/lib/services/conflict_resolution_service.dart` - 冲突解决机制

4. **后端API实现（约10页）**
   - `server/app/api/transactions.py` - 交易API接口
   - `server/app/services/ai_service.py` - AI服务后端实现
   - `server/app/models/transaction.py` - 后端数据模型

## 三、代码提取步骤

### 步骤1：准备工作

```bash
# 创建输出目录
mkdir -p 软著材料/源代码

# 创建代码提取脚本
touch extract_code.sh
chmod +x extract_code.sh
```

### 步骤2：提取前30页代码

```bash
#!/bin/bash

# 输出文件
OUTPUT_FILE="软著材料/源代码/前30页.txt"

# 清空输出文件
> "$OUTPUT_FILE"

# 页码计数器
page=1

# 函数：添加文件到输出
add_file() {
    local file=$1
    local max_lines=$2

    echo "=================================================================================" >> "$OUTPUT_FILE"
    echo "                              第${page}页" >> "$OUTPUT_FILE"
    echo "=================================================================================" >> "$OUTPUT_FILE"
    echo "// 文件: $file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"

    # 提取代码（每页50行）
    head -n $max_lines "$file" | tail -n 50 >> "$OUTPUT_FILE"

    page=$((page + 1))
}

# 按顺序添加文件
add_file "app/lib/main.dart" 50
add_file "app/lib/main.dart" 100
# ... 继续添加其他文件
```

### 步骤3：提取后30页代码

类似前30页的提取方式，选择后端和算法相关的代码文件。

### 步骤4：格式化和标注

1. **添加页码标注**
   - 每页顶部标注"第X页"
   - 每页底部标注文件路径

2. **添加文件路径**
   - 在每个新文件开始处标注完整路径
   - 格式：`// 文件: app/lib/services/xxx.dart`

3. **确保代码连续性**
   - 同一文件的代码应该连续
   - 如果一个文件跨多页，需要标注"（续）"

4. **代码格式统一**
   - 保持原有的缩进格式
   - 不要删除注释
   - 保留空行以提高可读性

## 四、代码质量检查

### 检查清单

- [ ] 代码总页数是否为60页（前30页+后30页）
- [ ] 每页是否为50行代码
- [ ] 页码标注是否清晰
- [ ] 文件路径是否完整
- [ ] 代码是否连续（同一文件内）
- [ ] 代码格式是否统一
- [ ] 是否包含核心功能代码
- [ ] 是否展示技术创新点
- [ ] 代码是否可读（有适当注释）
- [ ] 是否排除第三方库代码

### 常见问题

**Q1：代码中包含第三方库怎么办？**
A：应该选择自己编写的代码，避免包含第三方库的代码。如果必须包含，应该是对第三方库的封装和使用。

**Q2：代码中包含敏感信息怎么办？**
A：应该删除或替换敏感信息（如API密钥、密码等），用占位符代替。

**Q3：一个文件不足50行怎么办？**
A：可以在同一页中包含多个相关的小文件，但要清楚标注文件路径。

**Q4：代码跨页怎么处理？**
A：在下一页开始处标注"（续上页）"，并重新标注文件路径。

## 五、示例格式

```
=================================================================================
                              第1页
=================================================================================
// 文件: app/lib/main.dart
// 应用程序入口文件

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'theme/app_theme.dart';
import 'pages/main_navigation.dart';
import 'providers/theme_provider.dart';
import 'providers/locale_provider.dart';
import 'l10n/app_localizations.dart';
import 'l10n/generated/app_localizations.dart' as gen;
import 'core/logger.dart';
import 'services/cleanup_scheduler.dart';
import 'services/app_config_service.dart';
import 'services/http_service.dart';
import 'services/app_upgrade_service.dart';
import 'services/auto_sync_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize logging system
  await logger.init(
    config: LogConfig(
      maxFileSize: 5 * 1024 * 1024, // 5MB per file
      retentionDays: 7, // Keep logs for 7 days
      maxTotalSize: 50 * 1024 * 1024, // 50MB total max
      persistToFile: true,
      fileLogLevel: kDebugMode ? LogLevel.debug : LogLevel.info,
    ),
  );

  // Set system UI overlay style
  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.light,
    ),
  );

  // Log app startup
  logger.info('Application started', tag: 'App');

  // Initialize app configuration from server
  try {
    await AppConfigService().initialize();
    logger.info('App config service initialized', tag: 'App');

=================================================================================
                              第2页
=================================================================================
// 文件: app/lib/main.dart（续）

    // Reinitialize HTTP service with new config
    HttpService().reinitialize();
    logger.info('HTTP service reinitialized with server config', tag: 'App');
  } catch (e) {
    logger.warning('Failed to initialize app config: $e', tag: 'App');
  }

  // ... 继续代码
```

## 六、自动化提取工具

为了提高效率，可以编写自动化脚本来提取代码。以下是一个Python脚本示例：

```python
#!/usr/bin/env python3
import os

def extract_code(files, output_file, start_page=1):
    """提取代码到输出文件"""
    page = start_page

    with open(output_file, 'w', encoding='utf-8') as out:
        for file_path in files:
            if not os.path.exists(file_path):
                print(f"警告：文件不存在 {file_path}")
                continue

            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()

            # 每50行一页
            for i in range(0, len(lines), 50):
                chunk = lines[i:i+50]

                # 写入页头
                out.write("=" * 80 + "\n")
                out.write(f"{'第' + str(page) + '页':^80}\n")
                out.write("=" * 80 + "\n")
                out.write(f"// 文件: {file_path}\n")
                if i > 0:
                    out.write("// （续上页）\n")
                out.write("\n")

                # 写入代码
                out.writelines(chunk)
                out.write("\n")

                page += 1

                if page > 30:  # 前30页
                    return page

    return page

# 前30页文件列表
front_files = [
    "app/lib/main.dart",
    "app/lib/services/ocr_service.dart",
    "app/lib/services/voice/voice_recognition_service.dart",
    # ... 添加更多文件
]

# 后30页文件列表
back_files = [
    "app/lib/services/pocket_service.dart",
    "app/lib/services/money_age_service.dart",
    "server/app/api/transactions.py",
    # ... 添加更多文件
]

# 提取前30页
extract_code(front_files, "软著材料/源代码/前30页.txt", 1)

# 提取后30页
extract_code(back_files, "软著材料/源代码/后30页.txt", 1)
```

## 七、注意事项

1. **代码必须是自己编写的**：不要包含第三方库的源代码
2. **代码必须连续**：同一文件的代码应该连续，不要跳跃
3. **代码必须可读**：保留必要的注释和空行
4. **代码必须完整**：不要截断函数或类的定义
5. **格式必须统一**：使用统一的缩进和编码格式（UTF-8）
6. **页码必须清晰**：每页都要标注页码和文件路径
7. **避免敏感信息**：删除或替换API密钥、密码等敏感信息
8. **突出创新点**：优先选择能展示技术创新的代码

## 八、提交前检查

在提交源代码文档前，请完成以下检查：

- [ ] 总页数为60页（前30页+后30页）
- [ ] 每页50行代码
- [ ] 所有页码标注正确
- [ ] 所有文件路径标注完整
- [ ] 代码格式统一（UTF-8编码）
- [ ] 没有包含第三方库代码
- [ ] 没有敏感信息（API密钥、密码等）
- [ ] 代码能够展示软件的核心功能
- [ ] 代码能够展示技术创新点
- [ ] 代码可读性良好（有注释）
- [ ] 文件命名规范（如：前30页.txt、后30页.txt）
