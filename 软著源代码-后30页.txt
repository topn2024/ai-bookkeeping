================================================================================
                                     第1页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart

import '../models/budget_vault.dart';
import 'allocation_service.dart';
import 'vault_repository.dart';

/// 钱龄等级
enum MoneyAgeLevel {
  /// 危险 (< 7天)
  danger,

  /// 警告 (7-14天)
  warning,

  /// 正常 (14-30天)
  normal,

  /// 良好 (30-60天)
  good,

  /// 优秀 (60-90天)
  excellent,

  /// 理想 (90+天)
  ideal,
}

extension MoneyAgeLevelExtension on MoneyAgeLevel {
  String get displayName {
    switch (this) {
      case MoneyAgeLevel.danger:
        return '危险';
      case MoneyAgeLevel.warning:
        return '警告';
      case MoneyAgeLevel.normal:
        return '正常';
      case MoneyAgeLevel.good:
        return '良好';
      case MoneyAgeLevel.excellent:
        return '优秀';
      case MoneyAgeLevel.ideal:
        return '理想';
    }
  }

  /// 根据天数判断等级
  static MoneyAgeLevel fromDays(int days) {
    if (days < 7) return MoneyAgeLevel.danger;
    if (days < 14) return MoneyAgeLevel.warning;
    if (days < 30) return MoneyAgeLevel.normal;
    if (days < 60) return MoneyAgeLevel.good;
    if (days < 90) return MoneyAgeLevel.excellent;

================================================================================
                                     第2页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart
// （续上页）

    return MoneyAgeLevel.ideal;
  }
}

/// 钱龄数据
class MoneyAge {
  final int days;
  final MoneyAgeLevel level;

  const MoneyAge({required this.days, required this.level});

  factory MoneyAge.fromDays(int days) {
    return MoneyAge(
      days: days,
      level: MoneyAgeLevelExtension.fromDays(days),
    );
  }
}

/// 钱龄影响预测
class MoneyAgeImpactPrediction {
  final int currentAge;
  final int projectedAge;
  final int change;
  final String recommendation;
  final ImpactType impactType;

  const MoneyAgeImpactPrediction({
    required this.currentAge,
    required this.projectedAge,
    required this.change,
    required this.recommendation,
    required this.impactType,
  });

  bool get isPositive => change > 0;
  bool get isNegative => change < 0;
  bool get isNeutral => change == 0;
}

/// 影响类型
enum ImpactType {
  /// 提升
  positive,

  /// 降低
  negative,

  /// 无影响
  neutral,

================================================================================
                                     第3页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart
// （续上页）

}

/// 预算调整建议
class BudgetAdjustmentSuggestion {
  final AdjustmentType adjustmentType;
  final double targetPercentage;
  final String reason;
  final List<VaultAdjustment> vaultAdjustments;

  const BudgetAdjustmentSuggestion({
    required this.adjustmentType,
    required this.targetPercentage,
    required this.reason,
    this.vaultAdjustments = const [],
  });

  factory BudgetAdjustmentSuggestion.noChange() {
    return const BudgetAdjustmentSuggestion(
      adjustmentType: AdjustmentType.noChange,
      targetPercentage: 0,
      reason: '当前预算配置合理，无需调整',
    );
  }
}

/// 调整类型
enum AdjustmentType {
  /// 增加储蓄
  increaseSavings,

  /// 减少弹性支出
  reduceFlexible,

  /// 调整债务还款
  adjustDebt,

  /// 无需调整
  noChange,
}

/// 单个小金库的调整建议
class VaultAdjustment {
  final String vaultId;
  final String vaultName;
  final double currentAmount;
  final double suggestedAmount;
  final String reason;

  const VaultAdjustment({
    required this.vaultId,

================================================================================
                                     第4页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart
// （续上页）

    required this.vaultName,
    required this.currentAmount,
    required this.suggestedAmount,
    required this.reason,
  });

  double get change => suggestedAmount - currentAmount;
  bool get isIncrease => change > 0;
}

/// 预算执行与钱龄联动服务
///
/// 分析预算分配对钱龄的影响，提供联动建议
class BudgetMoneyAgeIntegration {
  final VaultRepository _vaultRepo;

  // 模拟钱龄计算器接口
  int _currentMoneyAgeDays = 30; // 当前钱龄天数
  double _dailySpending = 200; // 日均消费

  BudgetMoneyAgeIntegration(this._vaultRepo);

  /// 设置当前钱龄（用于测试和外部数据注入）
  void setCurrentMoneyAge(int days) {
    _currentMoneyAgeDays = days;
  }

  /// 设置日均消费
  void setDailySpending(double amount) {
    _dailySpending = amount;
  }

  /// 获取当前钱龄
  MoneyAge getCurrentMoneyAge() {
    return MoneyAge.fromDays(_currentMoneyAgeDays);
  }

  /// 分析预算分配对钱龄的预期影响
  Future<MoneyAgeImpactPrediction> predictAllocationImpact(
    List<AllocationSuggestion> allocations,
  ) async {
    final currentAge = _currentMoneyAgeDays;

    // 储蓄类小金库分配会提高钱龄
    double savingsImpact = 0;
    double flexibleImpact = 0;

    for (final alloc in allocations) {
      final vault = await _vaultRepo.getById(alloc.vaultId);
      if (vault == null) continue;

================================================================================
                                     第5页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart
// （续上页）


      if (vault.type == VaultType.savings) {
        // 储蓄相当于延迟消费，会提高钱龄
        // 每储蓄一天的消费额，钱龄增加约1天
        savingsImpact += alloc.suggestedAmount / _dailySpending;
      } else if (vault.type == VaultType.flexible) {
        // 弹性支出增加可能导致更多消费
        flexibleImpact -= alloc.suggestedAmount / _dailySpending * 0.3;
      }
    }

    final totalImpact = savingsImpact + flexibleImpact;
    final projectedAge = (currentAge + totalImpact).round();

    ImpactType impactType;
    String recommendation;

    if (totalImpact > 1) {
      impactType = ImpactType.positive;
      recommendation = '本次分配将提升钱龄约${totalImpact.round()}天';
    } else if (totalImpact < -1) {
      impactType = ImpactType.negative;
      recommendation = '本次分配可能降低钱龄约${(-totalImpact).round()}天，建议增加储蓄比例';
    } else {
      impactType = ImpactType.neutral;
      recommendation = '本次分配对钱龄无显著影响';
    }

    return MoneyAgeImpactPrediction(
      currentAge: currentAge,
      projectedAge: projectedAge,
      change: totalImpact.round(),
      recommendation: recommendation,
      impactType: impactType,
    );
  }

  /// 根据钱龄状态调整预算建议
  Future<BudgetAdjustmentSuggestion> suggestBudgetAdjustment() async {
    final moneyAge = getCurrentMoneyAge();

    if (moneyAge.level == MoneyAgeLevel.danger) {
      // 钱龄危险：建议增加储蓄预算比例
      return BudgetAdjustmentSuggestion(
        adjustmentType: AdjustmentType.increaseSavings,
        targetPercentage: 0.25, // 建议储蓄25%
        reason: '当前钱龄${moneyAge.days}天，建议提高储蓄比例以建立财务缓冲',
        vaultAdjustments: await _getSavingsAdjustments(0.25),
      );
    }

================================================================================
                                     第6页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart
// （续上页）


    if (moneyAge.level == MoneyAgeLevel.warning) {
      // 钱龄警告：建议适度增加储蓄
      return BudgetAdjustmentSuggestion(
        adjustmentType: AdjustmentType.increaseSavings,
        targetPercentage: 0.20,
        reason: '当前钱龄${moneyAge.days}天，建议适当增加储蓄比例',
        vaultAdjustments: await _getSavingsAdjustments(0.20),
      );
    }

    if (moneyAge.level == MoneyAgeLevel.normal) {
      // 钱龄正常：保持或小幅增加
      return BudgetAdjustmentSuggestion(
        adjustmentType: AdjustmentType.noChange,
        targetPercentage: 0.15,
        reason: '当前钱龄${moneyAge.days}天，预算配置合理，可保持或适当增加储蓄',
      );
    }

    // 钱龄良好以上：无需调整
    return BudgetAdjustmentSuggestion.noChange();
  }

  /// 获取储蓄调整建议
  Future<List<VaultAdjustment>> _getSavingsAdjustments(
    double targetSavingsRate,
  ) async {
    final vaults = await _vaultRepo.getEnabled();
    final adjustments = <VaultAdjustment>[];

    // 计算当前总分配
    final totalAllocated =
        vaults.fold(0.0, (sum, v) => sum + v.allocatedAmount);

    // 找出储蓄类小金库
    final savingsVaults = vaults.where((v) => v.type == VaultType.savings);

    // 当前储蓄占比
    final currentSavings =
        savingsVaults.fold(0.0, (sum, v) => sum + v.allocatedAmount);
    final currentSavingsRate =
        totalAllocated > 0 ? currentSavings / totalAllocated : 0;

    if (currentSavingsRate < targetSavingsRate && savingsVaults.isNotEmpty) {
      // 需要增加储蓄
      final additionalSavings =
          totalAllocated * (targetSavingsRate - currentSavingsRate);
      final perVaultIncrease = additionalSavings / savingsVaults.length;


================================================================================
                                     第7页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart
// （续上页）

      for (final vault in savingsVaults) {
        adjustments.add(VaultAdjustment(
          vaultId: vault.id,
          vaultName: vault.name,
          currentAmount: vault.allocatedAmount,
          suggestedAmount: vault.allocatedAmount + perVaultIncrease,
          reason: '建议增加储蓄以提升钱龄',
        ));
      }

      // 从弹性支出中减少
      final flexibleVaults = vaults.where((v) => v.type == VaultType.flexible);
      if (flexibleVaults.isNotEmpty) {
        final perVaultDecrease = additionalSavings / flexibleVaults.length;

        for (final vault in flexibleVaults) {
          final newAmount = (vault.allocatedAmount - perVaultDecrease)
              .clamp(vault.spentAmount, vault.allocatedAmount);

          if (newAmount < vault.allocatedAmount) {
            adjustments.add(VaultAdjustment(
              vaultId: vault.id,
              vaultName: vault.name,
              currentAmount: vault.allocatedAmount,
              suggestedAmount: newAmount,
              reason: '建议适当减少弹性支出',
            ));
          }
        }
      }
    }

    return adjustments;
  }

  /// 计算消费对钱龄的影响
  MoneyAgeImpactPrediction predictExpenseImpact(double expenseAmount) {
    final currentAge = _currentMoneyAgeDays;

    // 消费会降低钱龄
    // 假设每消费一天的平均消费额，钱龄降低约0.5天
    final impact = -(expenseAmount / _dailySpending * 0.5);
    final projectedAge = (currentAge + impact).round().clamp(0, 365);

    String recommendation;
    ImpactType impactType;

    if (impact < -3) {
      impactType = ImpactType.negative;
      recommendation = '这笔消费较大，将显著降低钱龄';

================================================================================
                                     第8页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart
// （续上页）

    } else if (impact < -1) {
      impactType = ImpactType.negative;
      recommendation = '这笔消费会略微降低钱龄';
    } else {
      impactType = ImpactType.neutral;
      recommendation = '对钱龄影响较小';
    }

    return MoneyAgeImpactPrediction(
      currentAge: currentAge,
      projectedAge: projectedAge,
      change: impact.round(),
      recommendation: recommendation,
      impactType: impactType,
    );
  }

  /// 获取钱龄优化建议
  Future<List<String>> getOptimizationTips() async {
    final tips = <String>[];
    final moneyAge = getCurrentMoneyAge();
    final vaults = await _vaultRepo.getEnabled();

    // 根据钱龄等级给出建议
    switch (moneyAge.level) {
      case MoneyAgeLevel.danger:
        tips.add('紧急：钱龄处于危险水平，建议立即增加储蓄');
        tips.add('考虑减少非必要支出');
        tips.add('检查是否有大额固定支出可以优化');
        break;
      case MoneyAgeLevel.warning:
        tips.add('警告：钱龄较低，建议关注支出结构');
        tips.add('尝试建立应急基金');
        break;
      case MoneyAgeLevel.normal:
        tips.add('钱龄正常，保持当前储蓄习惯');
        tips.add('可以考虑逐步增加储蓄比例');
        break;
      case MoneyAgeLevel.good:
      case MoneyAgeLevel.excellent:
      case MoneyAgeLevel.ideal:
        tips.add('钱龄健康，继续保持');
        tips.add('可以考虑长期投资');
        break;
    }

    // 检查小金库状态
    final overspentVaults = vaults.where((v) => v.isOverSpent);
    if (overspentVaults.isNotEmpty) {
      tips.add('有${overspentVaults.length}个小金库超支，建议及时调整');

================================================================================
                                     第9页                                      
================================================================================
// 文件: app/lib/services/budget_money_age_integration.dart
// （续上页）

    }

    return tips;
  }
}

// 文件结束，共 5 行

================================================================================
                                     第10页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart

import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import '../core/di/service_locator.dart';
import '../core/contracts/i_database_service.dart';
import 'offline_capability_service.dart';
import 'vector_clock.dart';

/// 家庭账本离线记账暂存服务
///
/// 功能：
/// 1. 离线时暂存家庭账本的记账操作
/// 2. 标记待同步状态
/// 3. 联网后自动合并到家庭账本
class FamilyOfflineStorageService {
  static final FamilyOfflineStorageService _instance = FamilyOfflineStorageService._internal();
  factory FamilyOfflineStorageService() => _instance;
  FamilyOfflineStorageService._internal();

  /// 通过服务定位器获取数据库服务
  IDatabaseService get _db => sl<IDatabaseService>();
  final OfflineCapabilityService _offlineService = OfflineCapabilityService();
  StreamSubscription<NetworkStatusInfo>? _statusSubscription;

  /// 暂存键前缀
  // ignore: unused_field
  static const String _storagePrefix = 'family_offline_';

  /// 初始化服务
  Future<void> initialize() async {
    // 监听网络恢复
    _statusSubscription = _offlineService.statusStream.listen((status) {
      if (status.isOnline) {
        syncPendingFamilyTransactions();
      }
    });
  }

  /// 释放资源
  void dispose() {
    _statusSubscription?.cancel();
  }

  /// 暂存家庭账本交易
  Future<String> storeOfflineTransaction({
    required String familyBookId,
    required String memberId,
    required Map<String, dynamic> transactionData,
  }) async {
    final id = DateTime.now().millisecondsSinceEpoch.toString();

================================================================================
                                     第11页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）


    final offlineTransaction = FamilyOfflineTransaction(
      id: id,
      familyBookId: familyBookId,
      memberId: memberId,
      transactionData: transactionData,
      createdAt: DateTime.now(),
      syncStatus: SyncStatus.pending,
    );

    // 保存到本地数据库
    final db = await _db.database;
    await db.insert('family_offline_transactions', offlineTransaction.toMap());

    debugPrint('Family transaction stored offline: $id');
    return id;
  }

  /// 获取待同步的家庭交易
  Future<List<FamilyOfflineTransaction>> getPendingTransactions(String familyBookId) async {
    final db = await _db.database;

    final results = await db.query(
      'family_offline_transactions',
      where: 'family_book_id = ? AND sync_status = ?',
      whereArgs: [familyBookId, SyncStatus.pending.index],
      orderBy: 'created_at ASC',
    );

    return results.map((r) => FamilyOfflineTransaction.fromMap(r)).toList();
  }

  /// 获取所有待同步的家庭交易
  Future<List<FamilyOfflineTransaction>> getAllPendingTransactions() async {
    final db = await _db.database;

    final results = await db.query(
      'family_offline_transactions',
      where: 'sync_status = ?',
      whereArgs: [SyncStatus.pending.index],
      orderBy: 'created_at ASC',
    );

    return results.map((r) => FamilyOfflineTransaction.fromMap(r)).toList();
  }

  /// 同步待处理的家庭交易
  Future<SyncResult> syncPendingFamilyTransactions() async {
    if (!_offlineService.isOnline) {
      return SyncResult(

================================================================================
                                     第12页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

        success: false,
        synced: 0,
        failed: 0,
        message: '设备离线',
      );
    }

    final pending = await getAllPendingTransactions();
    if (pending.isEmpty) {
      return SyncResult(success: true, synced: 0, failed: 0);
    }

    debugPrint('Syncing ${pending.length} family transactions...');

    int synced = 0;
    int failed = 0;

    for (final transaction in pending) {
      try {
        await _syncSingleTransaction(transaction);
        synced++;
      } catch (e) {
        debugPrint('Failed to sync family transaction ${transaction.id}: $e');
        failed++;
      }
    }

    return SyncResult(
      success: failed == 0,
      synced: synced,
      failed: failed,
    );
  }

  /// 同步单个交易
  Future<void> _syncSingleTransaction(FamilyOfflineTransaction transaction) async {
    final db = await _db.database;

    // 标记为同步中
    await db.update(
      'family_offline_transactions',
      {'sync_status': SyncStatus.syncing.index},
      where: 'id = ?',
      whereArgs: [transaction.id],
    );

    try {
      // 实际同步逻辑（通过API或CRDT同步）
      // 这里使用模拟延迟
      await Future.delayed(const Duration(milliseconds: 500));

================================================================================
                                     第13页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）


      // 标记为已同步
      await db.update(
        'family_offline_transactions',
        {
          'sync_status': SyncStatus.synced.index,
          'synced_at': DateTime.now().millisecondsSinceEpoch,
        },
        where: 'id = ?',
        whereArgs: [transaction.id],
      );

      debugPrint('Family transaction synced: ${transaction.id}');
    } catch (e) {
      // 同步失败，标记回pending
      await db.update(
        'family_offline_transactions',
        {
          'sync_status': SyncStatus.failed.index,
          'error_message': e.toString(),
        },
        where: 'id = ?',
        whereArgs: [transaction.id],
      );
      rethrow;
    }
  }

  /// 删除已同步的交易记录
  Future<int> clearSyncedTransactions() async {
    final db = await _db.database;

    return await db.delete(
      'family_offline_transactions',
      where: 'sync_status = ?',
      whereArgs: [SyncStatus.synced.index],
    );
  }

  /// 获取待同步数量
  Future<int> getPendingCount() async {
    final db = await _db.database;

    final result = await db.rawQuery('''
      SELECT COUNT(*) as count FROM family_offline_transactions
      WHERE sync_status = ?
    ''', [SyncStatus.pending.index]);

    return (result.first['count'] as int?) ?? 0;
  }

================================================================================
                                     第14页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

}

/// 家庭离线交易数据模型
class FamilyOfflineTransaction {
  final String id;
  final String familyBookId;
  final String memberId;
  final Map<String, dynamic> transactionData;
  final DateTime createdAt;
  final SyncStatus syncStatus;
  final DateTime? syncedAt;
  final String? errorMessage;

  const FamilyOfflineTransaction({
    required this.id,
    required this.familyBookId,
    required this.memberId,
    required this.transactionData,
    required this.createdAt,
    required this.syncStatus,
    this.syncedAt,
    this.errorMessage,
  });

  Map<String, dynamic> toMap() => {
    'id': id,
    'family_book_id': familyBookId,
    'member_id': memberId,
    'transaction_data': jsonEncode(transactionData),
    'created_at': createdAt.millisecondsSinceEpoch,
    'sync_status': syncStatus.index,
    'synced_at': syncedAt?.millisecondsSinceEpoch,
    'error_message': errorMessage,
  };

  factory FamilyOfflineTransaction.fromMap(Map<String, dynamic> map) {
    return FamilyOfflineTransaction(
      id: map['id'] as String,
      familyBookId: map['family_book_id'] as String,
      memberId: map['member_id'] as String,
      transactionData: jsonDecode(map['transaction_data'] as String),
      createdAt: DateTime.fromMillisecondsSinceEpoch(map['created_at'] as int),
      syncStatus: SyncStatus.values[map['sync_status'] as int],
      syncedAt: map['synced_at'] != null
          ? DateTime.fromMillisecondsSinceEpoch(map['synced_at'] as int)
          : null,
      errorMessage: map['error_message'] as String?,
    );
  }
}

================================================================================
                                     第15页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）


/// 同步状态
enum SyncStatus {
  pending,
  syncing,
  synced,
  failed,
}

/// 同步结果
class SyncResult {
  final bool success;
  final int synced;
  final int failed;
  final String? message;

  const SyncResult({
    required this.success,
    required this.synced,
    required this.failed,
    this.message,
  });
}

/// 同步冲突检测与解决服务
///
/// 功能：
/// 1. 检测数据冲突（基于向量时钟）
/// 2. 提供多种冲突解决策略
/// 3. 支持用户手动选择解决方案
class SyncConflictService {
  static final SyncConflictService _instance = SyncConflictService._internal();
  factory SyncConflictService() => _instance;
  SyncConflictService._internal();

  /// 通过服务定位器获取数据库服务
  IDatabaseService get _db => sl<IDatabaseService>();

  final _conflictController = StreamController<ConflictEvent>.broadcast();

  /// 冲突事件流
  Stream<ConflictEvent> get conflictStream => _conflictController.stream;

  /// 检测冲突
  Future<ConflictResult> detectConflict({
    required String entityType,
    required String entityId,
    required Map<String, dynamic> localData,
    required Map<String, dynamic> remoteData,
    required VectorClock localClock,

================================================================================
                                     第16页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

    required VectorClock remoteClock,
  }) async {
    // 比较向量时钟
    final comparison = localClock.compare(remoteClock);

    switch (comparison) {
      case ClockComparison.equal:
        // 时钟相等，无冲突
        return ConflictResult(
          hasConflict: false,
          type: ConflictType.none,
        );

      case ClockComparison.before:
        // 本地在远程之前，使用远程版本
        return ConflictResult(
          hasConflict: false,
          type: ConflictType.none,
          resolution: ConflictResolution.useRemote,
        );

      case ClockComparison.after:
        // 本地在远程之后，使用本地版本
        return ConflictResult(
          hasConflict: false,
          type: ConflictType.none,
          resolution: ConflictResolution.useLocal,
        );

      case ClockComparison.concurrent:
        // 并发修改，存在冲突
        final conflictType = _determineConflictType(localData, remoteData);
        return ConflictResult(
          hasConflict: true,
          type: conflictType,
          localData: localData,
          remoteData: remoteData,
          localClock: localClock,
          remoteClock: remoteClock,
        );
    }
  }

  /// 确定冲突类型
  ConflictType _determineConflictType(
    Map<String, dynamic> localData,
    Map<String, dynamic> remoteData,
  ) {
    // 检查是否是删除冲突
    final localDeleted = localData['deleted'] == true;

================================================================================
                                     第17页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

    final remoteDeleted = remoteData['deleted'] == true;

    if (localDeleted && !remoteDeleted) {
      return ConflictType.deleteUpdate;
    }
    if (!localDeleted && remoteDeleted) {
      return ConflictType.updateDelete;
    }
    if (localDeleted && remoteDeleted) {
      return ConflictType.deleteDelete;
    }

    // 检查修改的字段
    final localModified = _getModifiedFields(localData);
    final remoteModified = _getModifiedFields(remoteData);

    final overlapping = localModified.intersection(remoteModified);

    if (overlapping.isEmpty) {
      // 修改不同字段，可以自动合并
      return ConflictType.mergeable;
    }

    // 修改相同字段，需要用户选择
    return ConflictType.fieldConflict;
  }

  /// 获取修改的字段
  Set<String> _getModifiedFields(Map<String, dynamic> data) {
    // 假设有一个原始数据对比
    // 实际实现需要与原始数据进行对比
    return data.keys.toSet();
  }

  /// 自动解决冲突
  Future<Map<String, dynamic>> autoResolveConflict(
    ConflictResult conflict,
    ConflictResolutionStrategy strategy,
  ) async {
    switch (strategy) {
      case ConflictResolutionStrategy.localWins:
        return conflict.localData!;

      case ConflictResolutionStrategy.remoteWins:
        return conflict.remoteData!;

      case ConflictResolutionStrategy.latestWins:
        // 比较更新时间
        final localUpdated = DateTime.parse(
            conflict.localData!['updated_at'] as String);

================================================================================
                                     第18页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

        final remoteUpdated = DateTime.parse(
            conflict.remoteData!['updated_at'] as String);
        return localUpdated.isAfter(remoteUpdated)
            ? conflict.localData!
            : conflict.remoteData!;

      case ConflictResolutionStrategy.merge:
        return _mergeData(conflict.localData!, conflict.remoteData!);

      case ConflictResolutionStrategy.manual:
        // 需要用户手动解决
        throw ConflictException('Manual resolution required');
    }
  }

  /// 合并数据（非冲突字段自动合并）
  Map<String, dynamic> _mergeData(
    Map<String, dynamic> local,
    Map<String, dynamic> remote,
  ) {
    final merged = Map<String, dynamic>.from(remote);

    // 对于每个本地字段，如果远程没有或相同，使用本地值
    for (final entry in local.entries) {
      if (!merged.containsKey(entry.key) ||
          merged[entry.key] == null) {
        merged[entry.key] = entry.value;
      }
    }

    return merged;
  }

  /// 解决冲突（使用指定解决方案）
  Future<void> resolveConflict({
    required String entityType,
    required String entityId,
    required ConflictResolution resolution,
    required Map<String, dynamic> resolvedData,
    required VectorClock mergedClock,
  }) async {
    final db = await _db.database;

    // 更新本地数据
    await db.update(
      entityType,
      {
        ...resolvedData,
        'vector_clock': jsonEncode(mergedClock.toMap()),
        'updated_at': DateTime.now().toIso8601String(),

================================================================================
                                     第19页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

      },
      where: 'id = ?',
      whereArgs: [entityId],
    );

    // 记录冲突解决日志
    await db.insert('conflict_logs', {
      'entity_type': entityType,
      'entity_id': entityId,
      'resolution': resolution.name,
      'resolved_at': DateTime.now().toIso8601String(),
    });

    debugPrint('Conflict resolved for $entityType:$entityId using $resolution');
  }

  /// 获取冲突历史
  Future<List<ConflictLog>> getConflictHistory({
    String? entityType,
    int limit = 50,
  }) async {
    final db = await _db.database;

    String? where;
    List<dynamic>? whereArgs;

    if (entityType != null) {
      where = 'entity_type = ?';
      whereArgs = [entityType];
    }

    final results = await db.query(
      'conflict_logs',
      where: where,
      whereArgs: whereArgs,
      orderBy: 'resolved_at DESC',
      limit: limit,
    );

    return results.map((r) => ConflictLog.fromMap(r)).toList();
  }

  /// 发送冲突通知
  void notifyConflict(ConflictEvent event) {
    _conflictController.add(event);
  }

  /// 释放资源
  void dispose() {
    _conflictController.close();

================================================================================
                                     第20页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

  }
}

/// 冲突结果
class ConflictResult {
  final bool hasConflict;
  final ConflictType type;
  final ConflictResolution? resolution;
  final Map<String, dynamic>? localData;
  final Map<String, dynamic>? remoteData;
  final VectorClock? localClock;
  final VectorClock? remoteClock;

  const ConflictResult({
    required this.hasConflict,
    required this.type,
    this.resolution,
    this.localData,
    this.remoteData,
    this.localClock,
    this.remoteClock,
  });
}

/// 冲突类型
enum ConflictType {
  /// 无冲突
  none,

  /// 可自动合并（修改不同字段）
  mergeable,

  /// 字段冲突（修改相同字段）
  fieldConflict,

  /// 本地删除，远程更新
  deleteUpdate,

  /// 本地更新，远程删除
  updateDelete,

  /// 双方都删除
  deleteDelete,
}

/// 冲突解决方式
enum ConflictResolution {
  useLocal,
  useRemote,
  merge,

================================================================================
                                     第21页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

  manual,
}

/// 冲突解决策略
enum ConflictResolutionStrategy {
  /// 本地优先
  localWins,

  /// 远程优先
  remoteWins,

  /// 最新优先
  latestWins,

  /// 自动合并
  merge,

  /// 手动解决
  manual,
}

/// 冲突事件
class ConflictEvent {
  final String entityType;
  final String entityId;
  final ConflictResult conflict;
  final DateTime occurredAt;

  const ConflictEvent({
    required this.entityType,
    required this.entityId,
    required this.conflict,
    required this.occurredAt,
  });
}

/// 冲突日志
class ConflictLog {
  final String entityType;
  final String entityId;
  final ConflictResolution resolution;
  final DateTime resolvedAt;

  const ConflictLog({
    required this.entityType,
    required this.entityId,
    required this.resolution,
    required this.resolvedAt,
  });


================================================================================
                                     第22页                                     
================================================================================
// 文件: app/lib/services/family_offline_sync_service.dart
// （续上页）

  factory ConflictLog.fromMap(Map<String, dynamic> map) {
    return ConflictLog(
      entityType: map['entity_type'] as String,
      entityId: map['entity_id'] as String,
      resolution: ConflictResolution.values.firstWhere(
        (e) => e.name == map['resolution'],
      ),
      resolvedAt: DateTime.parse(map['resolved_at'] as String),
    );
  }
}

/// 冲突异常
class ConflictException implements Exception {
  final String message;
  ConflictException(this.message);

  @override
  String toString() => 'ConflictException: $message';
}

// 文件结束，共 20 行

================================================================================
                                     第23页                                     
================================================================================
// 文件: app/lib/services/encryption_service.dart

import 'dart:convert';
import 'package:crypto/crypto.dart';

/// 加密服务 - 提供密码哈希和数据加密功能
class EncryptionService {
  static final EncryptionService _instance = EncryptionService._internal();
  factory EncryptionService() => _instance;
  EncryptionService._internal();

  // 用于密码哈希的盐值前缀
  static const String _saltPrefix = 'ai_bookkeeping_';

  /// 对密码进行SHA256哈希
  /// 使用固定盐值+密码的方式生成哈希
  String hashPassword(String password, {String? salt}) {
    final effectiveSalt = salt ?? _saltPrefix;
    final bytes = utf8.encode('$effectiveSalt$password');
    final digest = sha256.convert(bytes);
    return digest.toString();
  }

  /// 验证密码是否匹配
  bool verifyPassword(String password, String hashedPassword, {String? salt}) {
    final hash = hashPassword(password, salt: salt);
    return hash == hashedPassword;
  }

  /// 生成随机盐值
  String generateSalt() {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final bytes = utf8.encode('$_saltPrefix$timestamp');
    final digest = sha256.convert(bytes);
    return digest.toString().substring(0, 16);
  }

  /// 对敏感数据进行HMAC签名
  String signData(String data, String secretKey) {
    final key = utf8.encode(secretKey);
    final bytes = utf8.encode(data);
    final hmacSha256 = Hmac(sha256, key);
    final digest = hmacSha256.convert(bytes);
    return digest.toString();
  }

  /// 验证HMAC签名
  bool verifySignature(String data, String signature, String secretKey) {
    final expectedSignature = signData(data, secretKey);
    return expectedSignature == signature;
  }


================================================================================
                                     第24页                                     
================================================================================
// 文件: app/lib/services/encryption_service.dart
// （续上页）

  /// 对数据进行Base64编码（用于传输）
  String encodeBase64(String data) {
    final bytes = utf8.encode(data);
    return base64.encode(bytes);
  }

  /// 对Base64数据进行解码
  String decodeBase64(String encodedData) {
    final bytes = base64.decode(encodedData);
    return utf8.decode(bytes);
  }

  /// 加密数据（简易实现，使用Base64编码）
  /// TODO: 在生产环境中应使用AES或其他安全加密算法
  Future<String> encrypt(String data) async {
    // 添加简单的混淆前缀
    final obfuscated = '${_saltPrefix}enc_$data';
    return encodeBase64(obfuscated);
  }

  /// 解密数据
  Future<String> decrypt(String encryptedData) async {
    final decoded = decodeBase64(encryptedData);
    // 移除混淆前缀
    final prefix = '${_saltPrefix}enc_';
    if (decoded.startsWith(prefix)) {
      return decoded.substring(prefix.length);
    }
    return decoded;
  }

  /// 生成用于API请求的签名
  /// 用于验证请求的完整性
  String generateApiSignature({
    required String method,
    required String path,
    required String timestamp,
    required String secretKey,
    Map<String, dynamic>? body,
  }) {
    final bodyString = body != null ? jsonEncode(body) : '';
    final data = '$method|$path|$timestamp|$bodyString';
    return signData(data, secretKey);
  }
}

// 文件结束，共 45 行

================================================================================
                                     第25页                                     
================================================================================
// 文件: server/app/main.py

"""FastAPI application entry point."""
import logging
from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.core.config import settings
from app.core.database import engine
from app.core.logging import setup_logging, get_logger
from app.core.redis import get_redis, close_redis, redis_manager
from app.middleware import (
    RequestLoggingMiddleware,
    SlowRequestLoggingMiddleware,
    RateLimitMiddleware,
    IdempotencyMiddleware,
)
from app.middleware.api_version import APIVersionMiddleware
from app.models import *  # noqa: Import all models for table creation
from app.api.v1 import api_router
from app.services.init_service import init_system_categories
from app.core.database import AsyncSessionLocal

# Admin API
from admin.api import admin_router

# Initialize logging first
setup_logging()
logger = get_logger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events."""
    logger.info("Application starting up...")

    # Initialize Redis connection (using enhanced manager)
    await redis_manager.connect(settings.REDIS_URL)
    redis_client = await get_redis()
    if redis_client:
        logger.info("Redis connection initialized for rate limiting and caching")
    else:
        logger.warning("Redis not available, rate limiting and caching will be disabled")

    # Initialize distributed consistency services
    logger.info("Initializing distributed consistency services...")
    try:
        from app.services.cache_consistency_service import cache_service
        from app.services.distributed_lock_service import distributed_lock
        from app.services.data_integrity_service import data_integrity

================================================================================
                                     第26页                                     
================================================================================
// 文件: server/app/main.py
// （续上页）


        # Services are singletons, just log their availability
        logger.info(f"Cache service initialized (hit_rate tracking enabled)")
        logger.info(f"Distributed lock service initialized")
        logger.info(f"Data integrity service initialized")
    except ImportError as e:
        logger.warning(f"Some distributed services unavailable: {e}")

    # Startup: Create tables and initialize system data
    async with engine.begin() as conn:
        # Create all tables
        from app.core.database import Base
        await conn.run_sync(Base.metadata.create_all)
        logger.info("Database tables created/verified")

    # Initialize system categories
    async with AsyncSessionLocal() as db:
        await init_system_categories(db)
        await db.commit()
        logger.info("System categories initialized")

    logger.info(f"Application {settings.APP_NAME} started successfully")
    yield

    # Shutdown
    logger.info("Application shutting down...")

    # Cleanup distributed services
    try:
        from app.services.cache_consistency_service import cache_service
        from app.services.distributed_lock_service import distributed_lock

        await cache_service.close()
        logger.info("Cache service closed")

        await distributed_lock.close()
        logger.info("Distributed lock service closed")
    except Exception as e:
        logger.warning(f"Error closing distributed services: {e}")

    await close_redis()
    logger.info("Redis connection closed")
    await engine.dispose()
    logger.info("Database connections closed")


app = FastAPI(
    title=settings.APP_NAME,
    version="1.0.0",
    description="AI-powered personal bookkeeping API",

================================================================================
                                     第27页                                     
================================================================================
// 文件: server/app/main.py
// （续上页）

    lifespan=lifespan,
)

# CORS middleware
cors_origins = settings.CORS_ORIGINS.split(",") if settings.CORS_ORIGINS != "*" else ["*"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Logging middleware (order matters: last added = first executed)
app.add_middleware(SlowRequestLoggingMiddleware)
app.add_middleware(RequestLoggingMiddleware)

# Rate limiting middleware
app.add_middleware(RateLimitMiddleware, enabled=True)

# Idempotency middleware
app.add_middleware(IdempotencyMiddleware)

# API Version compatibility middleware
app.add_middleware(APIVersionMiddleware)

# Include API routes
app.include_router(api_router, prefix="/api/v1")

# Include Admin API routes
app.include_router(admin_router, prefix="/admin")


@app.get("/health")
async def health_check():
    """Health check endpoint - basic liveness check."""
    from app.middleware.api_version import APIVersionConfig
    return {
        "status": "healthy",
        "service": settings.APP_NAME,
        "api_version": APIVersionConfig.CURRENT_VERSION,
    }


@app.get("/live")
async def liveness_check():
    """Kubernetes liveness probe endpoint.

    Returns 200 if the application is running.
    This is a lightweight check that doesn't verify dependencies.

================================================================================
                                     第28页                                     
================================================================================
// 文件: server/app/main.py
// （续上页）

    """
    return {"status": "alive"}


@app.get("/ready")
async def readiness_check():
    """Kubernetes readiness probe endpoint.

    Returns 200 if the application is ready to receive traffic.
    Checks all critical dependencies (database, Redis, etc.).
    """
    from sqlalchemy import text
    from app.core.circuit_breaker import get_all_circuit_breakers

    checks = {
        "database": {"status": "unknown", "latency_ms": 0},
        "redis": {"status": "unknown", "latency_ms": 0},
    }
    all_healthy = True

    # Check database connection
    import time
    try:
        start = time.perf_counter()
        async with AsyncSessionLocal() as db:
            await db.execute(text("SELECT 1"))
        latency = (time.perf_counter() - start) * 1000
        checks["database"] = {"status": "healthy", "latency_ms": round(latency, 2)}
    except Exception as e:
        logger.error(f"Database health check failed: {e}")
        checks["database"] = {"status": "unhealthy", "error": str(e)}
        all_healthy = False

    # Check Redis connection (using enhanced manager)
    try:
        redis_health = await redis_manager.health_check()
        if redis_health.get("connected"):
            checks["redis"] = {
                "status": "healthy",
                "latency_ms": redis_health.get("latency_ms", 0),
                "version": redis_health.get("redis_version", "unknown"),
            }
        else:
            checks["redis"] = {
                "status": "not_configured",
                "error": redis_health.get("error"),
            }
    except Exception as e:
        logger.error(f"Redis health check failed: {e}")
        checks["redis"] = {"status": "unhealthy", "error": str(e)}

================================================================================
                                     第29页                                     
================================================================================
// 文件: server/app/main.py
// （续上页）

        all_healthy = False

    # Check distributed services
    try:
        from app.services.cache_consistency_service import cache_service
        from app.services.distributed_lock_service import distributed_lock
        from app.services.data_integrity_service import data_integrity

        checks["distributed_services"] = {
            "cache": cache_service.get_stats_summary(),
            "lock": distributed_lock.get_stats_summary(),
            "integrity": data_integrity.get_summary(),
        }
    except Exception as e:
        checks["distributed_services"] = {"status": "unavailable", "error": str(e)}

    # Check circuit breakers
    circuit_breakers = get_all_circuit_breakers()
    cb_status = {}
    for name, cb in circuit_breakers.items():
        cb_info = cb.get_status()
        cb_status[name] = {
            "state": cb_info["state"],
            "failures": cb_info["stats"]["consecutive_failures"],
        }
        if cb.is_open:
            all_healthy = False

    if cb_status:
        checks["circuit_breakers"] = cb_status

    from fastapi.responses import JSONResponse

    status_code = 200 if all_healthy else 503
    return JSONResponse(
        status_code=status_code,
        content={
            "status": "ready" if all_healthy else "not_ready",
            "checks": checks,
        }
    )


@app.get("/")
async def root():
    """Root endpoint."""
    from app.middleware.api_version import APIVersionConfig
    return {
        "message": f"Welcome to {settings.APP_NAME} API",
        "docs": "/docs",

================================================================================
                                     第30页                                     
================================================================================
// 文件: server/app/main.py
// （续上页）

        "version": "1.0.0",
        "api_version": APIVersionConfig.CURRENT_VERSION,
        "min_api_version": APIVersionConfig.MIN_SUPPORTED_VERSION,
    }

// 文件结束，共 4 行

