# -*- coding: utf-8 -*-
"""
æ·»åŠ å®¶åº­è´¦æœ¬ä¸å¤šæˆå‘˜ç®¡ç†ç³»ç»Ÿç« èŠ‚
"""

FAMILY_CHAPTER = '''

## 13. å®¶åº­è´¦æœ¬ä¸å¤šæˆå‘˜ç®¡ç†ç³»ç»Ÿ

### 13.0 è®¾è®¡åŸåˆ™å›é¡¾

æœ¬ç« å®šä¹‰AIè®°è´¦åº”ç”¨çš„å®¶åº­è´¦æœ¬ä¸å¤šæˆå‘˜åä½œç³»ç»Ÿï¼Œä¸ºå®¶åº­ç†è´¢è€…æä¾›å…±äº«è®°è´¦ã€é¢„ç®—åä½œã€æ”¯å‡ºè¿½è¸ªç­‰æ ¸å¿ƒèƒ½åŠ›ã€‚

#### 13.0.1 å®¶åº­è´¦æœ¬è®¾è®¡åŸåˆ™çŸ©é˜µ

| è®¾è®¡åŸåˆ™ | åœ¨å®¶åº­è´¦æœ¬ä¸­çš„ä½“ç° | å®ç°æ–¹å¼ |
|----------|-------------------|----------|
| **æ‡’äººè®¾è®¡** | ä¸€é”®é‚€è¯·å®¶äººï¼Œè‡ªåŠ¨åŒæ­¥ | äºŒç»´ç é‚€è¯·ï¼Œå®æ—¶æ•°æ®åŒæ­¥ |
| **ä¼™ä¼´åŒ–** | å®¶åº­æˆå‘˜äº’åŠ¨æ¿€åŠ± | æˆå‘˜è´¡çŒ®æ’è¡Œï¼Œå…±åŒç›®æ ‡è¾¾æˆåº†ç¥ |
| **éšç§ä¼˜å…ˆ** | ä¸ªäººéšç§ä¸å®¶åº­å…±äº«å¹³è¡¡ | çµæ´»çš„å¯è§æ€§æ§åˆ¶ï¼Œæ•æ„Ÿè´¦ç›®éšè— |
| **æ¸è¿›å¼** | ä»ä¸ªäººè´¦æœ¬å¹³æ»‘è¿‡æ¸¡åˆ°å®¶åº­ | ä¿ç•™ä¸ªäººè´¦æœ¬ï¼ŒæŒ‰éœ€å¼€å¯å…±äº« |
| **å¼€æ”¾é›†æˆ** | ä¸å…¶ä»–ç³»ç»Ÿæ— ç¼åä½œ | ç»Ÿä¸€çš„è´¦æœ¬åˆ‡æ¢ï¼Œé¢„ç®—/é’±é¾„è”åŠ¨ |

#### 13.0.2 è®¾è®¡ç†å¿µ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         å®¶åº­è´¦æœ¬ç³»ç»Ÿè®¾è®¡ç†å¿µ                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚   ğŸ¯ æ ¸å¿ƒç›®æ ‡ï¼šè®©å®¶åº­è´¢åŠ¡ç®¡ç†é€æ˜ã€åä½œã€é«˜æ•ˆ                                   â”‚
â”‚                                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚  è®¾è®¡ç†å¿µï¼šå…±äº«ä¸å¤±ç§å¯†ï¼Œåä½œä¸å¢è´Ÿæ‹…ï¼Œé€æ˜ä¿ƒè¿›æ²Ÿé€š                         â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                              â”‚
â”‚   å››å¤§æ ¸å¿ƒèƒ½åŠ›ï¼š                                                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  å¤šè´¦æœ¬ç®¡ç†   â”‚  â”‚  æˆå‘˜åä½œ    â”‚  â”‚  é¢„ç®—å…±äº«    â”‚  â”‚  æ”¯å‡ºè¿½è¸ª    â”‚   â”‚
â”‚   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚   â”‚
â”‚   â”‚ ä¸ªäºº/å®¶åº­/   â”‚  â”‚ é‚€è¯·æˆå‘˜ï¼Œ   â”‚  â”‚ å®¶åº­é¢„ç®—åˆ†é… â”‚  â”‚ è°èŠ±äº†å¤šå°‘   â”‚   â”‚
â”‚   â”‚ ä¸“é¡¹è´¦æœ¬     â”‚  â”‚ è§’è‰²æƒé™     â”‚  â”‚ AAåˆ¶åˆ†æ‘Š     â”‚  â”‚ åˆ†ç±»è´¡çŒ®     â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 13.0.3 ä¸å…¶ä»–ç³»ç»Ÿçš„å…³ç³»

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      å®¶åº­è´¦æœ¬ç³»ç»Ÿä¸å…¶ä»–æ¨¡å—çš„å…³ç³»                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚                        â”‚   13. å®¶åº­è´¦æœ¬ç³»ç»Ÿ       â”‚                           â”‚
â”‚                        â”‚      ï¼ˆæœ¬ç« ï¼‰            â”‚                           â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                    â”‚                                         â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚        â”‚                           â”‚                           â”‚             â”‚
â”‚        â–¼                           â–¼                           â–¼             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚   â”‚ 7.é’±é¾„   â”‚              â”‚ 8.é¢„ç®—   â”‚              â”‚ 9.ä¹ æƒ¯   â”‚          â”‚
â”‚   â”‚  ç³»ç»Ÿ    â”‚              â”‚  ç³»ç»Ÿ    â”‚              â”‚  åŸ¹å…»    â”‚          â”‚
â”‚   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ â”‚              â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ â”‚              â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ â”‚          â”‚
â”‚   â”‚ å®¶åº­é’±é¾„ â”‚              â”‚ å®¶åº­é¢„ç®— â”‚              â”‚ å®¶åº­ä¹ æƒ¯ â”‚          â”‚
â”‚   â”‚ æˆå‘˜è´¡çŒ® â”‚              â”‚ æˆå‘˜é…é¢ â”‚              â”‚ å…±åŒç›®æ ‡ â”‚          â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚        â”‚                           â”‚                           â”‚             â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                    â–¼                                         â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚                        â”‚   12. æ•°æ®è”åŠ¨ä¸å¯è§†åŒ–   â”‚                           â”‚
â”‚                        â”‚   - å®¶åº­æŠ¥è¡¨             â”‚                           â”‚
â”‚                        â”‚   - æˆå‘˜å¯¹æ¯”åˆ†æ         â”‚                           â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 13.1 è´¦æœ¬ä½“ç³»æ¶æ„

#### 13.1.1 è´¦æœ¬ç±»å‹å®šä¹‰

```dart
/// è´¦æœ¬ç±»å‹æšä¸¾
enum LedgerType {
  personal,    // ä¸ªäººè´¦æœ¬ï¼ˆé»˜è®¤ï¼Œç§æœ‰ï¼‰
  family,      // å®¶åº­è´¦æœ¬ï¼ˆå¤šæˆå‘˜å…±äº«ï¼‰
  couple,      // æƒ…ä¾£è´¦æœ¬ï¼ˆä¸¤äººå…±äº«ï¼‰
  group,       // ç¾¤ç»„è´¦æœ¬ï¼ˆå¤šäººAAï¼‰
  project,     // ä¸“é¡¹è´¦æœ¬ï¼ˆè£…ä¿®ã€æ—…è¡Œç­‰ï¼‰
}

/// è´¦æœ¬å®ä½“
class Ledger {
  final String id;
  final String name;
  final LedgerType type;
  final String ownerId;           // åˆ›å»ºè€…/æ‰€æœ‰è€…
  final String? iconEmoji;        // è´¦æœ¬å›¾æ ‡
  final String? coverColor;       // å°é¢é¢œè‰²
  final DateTime createdAt;
  final LedgerSettings settings;
  final List<LedgerMember> members;
  final LedgerStats stats;

  Ledger({
    required this.id,
    required this.name,
    required this.type,
    required this.ownerId,
    this.iconEmoji,
    this.coverColor,
    required this.createdAt,
    required this.settings,
    required this.members,
    required this.stats,
  });

  /// æ˜¯å¦ä¸ºå…±äº«è´¦æœ¬
  bool get isShared => type != LedgerType.personal;

  /// è·å–æˆå‘˜æ•°é‡
  int get memberCount => members.length;

  /// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™
  bool hasPermission(String userId, LedgerPermission permission) {
    final member = members.firstWhereOrNull((m) => m.userId == userId);
    if (member == null) return false;
    return member.role.hasPermission(permission);
  }
}

/// è´¦æœ¬è®¾ç½®
class LedgerSettings {
  final String defaultCurrency;       // é»˜è®¤è´§å¸
  final bool autoSyncEnabled;         // è‡ªåŠ¨åŒæ­¥
  final bool notifyOnNewTransaction;  // æ–°äº¤æ˜“é€šçŸ¥
  final bool notifyOnBudgetAlert;     // é¢„ç®—å‘Šè­¦é€šçŸ¥
  final VisibilityLevel defaultVisibility;  // é»˜è®¤å¯è§æ€§
  final bool allowMemberInvite;       // å…è®¸æˆå‘˜é‚€è¯·ä»–äºº
  final int? monthlyBudgetLimit;      // æœˆåº¦é¢„ç®—ä¸Šé™

  LedgerSettings({
    this.defaultCurrency = 'CNY',
    this.autoSyncEnabled = true,
    this.notifyOnNewTransaction = true,
    this.notifyOnBudgetAlert = true,
    this.defaultVisibility = VisibilityLevel.allMembers,
    this.allowMemberInvite = false,
    this.monthlyBudgetLimit,
  });
}

/// å¯è§æ€§çº§åˆ«
enum VisibilityLevel {
  private,      // ä»…è‡ªå·±å¯è§
  allMembers,   // æ‰€æœ‰æˆå‘˜å¯è§
  adminsOnly,   // ä»…ç®¡ç†å‘˜å¯è§
  custom,       // è‡ªå®šä¹‰å¯è§æˆå‘˜
}
```

#### 13.1.2 è´¦æœ¬ç®¡ç†æœåŠ¡

```dart
/// è´¦æœ¬ç®¡ç†æœåŠ¡
class LedgerService {
  final LedgerRepository _repository;
  final MemberService _memberService;
  final SyncService _syncService;
  final NotificationService _notificationService;

  // å½“å‰æ´»è·ƒè´¦æœ¬
  final ValueNotifier<Ledger?> currentLedger = ValueNotifier(null);

  // ç”¨æˆ·çš„æ‰€æœ‰è´¦æœ¬
  final ValueNotifier<List<Ledger>> userLedgers = ValueNotifier([]);

  LedgerService(
    this._repository,
    this._memberService,
    this._syncService,
    this._notificationService,
  );

  /// åˆ›å»ºè´¦æœ¬
  Future<Ledger> createLedger({
    required String name,
    required LedgerType type,
    String? iconEmoji,
    String? coverColor,
    LedgerSettings? settings,
  }) async {
    final userId = AuthService().currentUserId;

    final ledger = Ledger(
      id: generateUuid(),
      name: name,
      type: type,
      ownerId: userId,
      iconEmoji: iconEmoji ?? _getDefaultEmoji(type),
      coverColor: coverColor,
      createdAt: DateTime.now(),
      settings: settings ?? LedgerSettings(),
      members: [
        LedgerMember(
          userId: userId,
          role: MemberRole.owner,
          joinedAt: DateTime.now(),
        ),
      ],
      stats: LedgerStats.empty(),
    );

    await _repository.create(ledger);
    await _refreshUserLedgers();

    return ledger;
  }

  String _getDefaultEmoji(LedgerType type) {
    switch (type) {
      case LedgerType.personal: return 'ğŸ“”';
      case LedgerType.family: return 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦';
      case LedgerType.couple: return 'ğŸ’‘';
      case LedgerType.group: return 'ğŸ‘¥';
      case LedgerType.project: return 'ğŸ“‹';
    }
  }

  /// åˆ‡æ¢å½“å‰è´¦æœ¬
  Future<void> switchLedger(String ledgerId) async {
    final ledger = await _repository.getById(ledgerId);
    if (ledger == null) throw LedgerNotFoundException();

    // æ£€æŸ¥æƒé™
    final userId = AuthService().currentUserId;
    if (!ledger.members.any((m) => m.userId == userId)) {
      throw NoPermissionException();
    }

    currentLedger.value = ledger;
    await _syncService.syncLedgerData(ledgerId);

    // ä¿å­˜æœ€åä½¿ç”¨çš„è´¦æœ¬
    await PreferencesService().setLastLedgerId(ledgerId);
  }

  /// è·å–ç”¨æˆ·çš„æ‰€æœ‰è´¦æœ¬
  Future<List<Ledger>> getUserLedgers() async {
    final userId = AuthService().currentUserId;
    final ledgers = await _repository.getByUserId(userId);
    userLedgers.value = ledgers;
    return ledgers;
  }

  /// åˆ é™¤è´¦æœ¬
  Future<void> deleteLedger(String ledgerId) async {
    final ledger = await _repository.getById(ledgerId);
    if (ledger == null) return;

    final userId = AuthService().currentUserId;
    if (ledger.ownerId != userId) {
      throw NoPermissionException('åªæœ‰è´¦æœ¬æ‰€æœ‰è€…å¯ä»¥åˆ é™¤è´¦æœ¬');
    }

    // é€šçŸ¥æ‰€æœ‰æˆå‘˜
    for (final member in ledger.members) {
      if (member.userId != userId) {
        await _notificationService.send(
          member.userId,
          NotificationType.ledgerDeleted,
          {'ledgerName': ledger.name},
        );
      }
    }

    await _repository.delete(ledgerId);
    await _refreshUserLedgers();

    // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰è´¦æœ¬ï¼Œåˆ‡æ¢åˆ°ä¸ªäººè´¦æœ¬
    if (currentLedger.value?.id == ledgerId) {
      await _switchToPersonalLedger();
    }
  }

  Future<void> _switchToPersonalLedger() async {
    final ledgers = userLedgers.value;
    final personal = ledgers.firstWhereOrNull(
      (l) => l.type == LedgerType.personal
    );
    if (personal != null) {
      await switchLedger(personal.id);
    }
  }

  Future<void> _refreshUserLedgers() async {
    await getUserLedgers();
  }
}
```

### 13.2 æˆå‘˜ç®¡ç†ç³»ç»Ÿ

#### 13.2.1 æˆå‘˜è§’è‰²ä¸æƒé™

```dart
/// æˆå‘˜è§’è‰²
enum MemberRole {
  owner,    // æ‰€æœ‰è€…ï¼šå…¨éƒ¨æƒé™
  admin,    // ç®¡ç†å‘˜ï¼šé™¤åˆ é™¤è´¦æœ¬å¤–çš„å…¨éƒ¨æƒé™
  member,   // æˆå‘˜ï¼šè®°è´¦ã€æŸ¥çœ‹
  viewer,   // æŸ¥çœ‹è€…ï¼šä»…æŸ¥çœ‹
}

/// æƒé™ç±»å‹
enum LedgerPermission {
  // è´¦æœ¬ç®¡ç†
  editLedgerSettings,     // ç¼–è¾‘è´¦æœ¬è®¾ç½®
  deleteLedger,           // åˆ é™¤è´¦æœ¬
  inviteMember,           // é‚€è¯·æˆå‘˜
  removeMember,           // ç§»é™¤æˆå‘˜
  changeMemberRole,       // ä¿®æ”¹æˆå‘˜è§’è‰²

  // äº¤æ˜“æ“ä½œ
  createTransaction,      // åˆ›å»ºäº¤æ˜“
  editOwnTransaction,     // ç¼–è¾‘è‡ªå·±çš„äº¤æ˜“
  editAnyTransaction,     // ç¼–è¾‘ä»»ä½•äº¤æ˜“
  deleteOwnTransaction,   // åˆ é™¤è‡ªå·±çš„äº¤æ˜“
  deleteAnyTransaction,   // åˆ é™¤ä»»ä½•äº¤æ˜“

  // é¢„ç®—æ“ä½œ
  viewBudget,             // æŸ¥çœ‹é¢„ç®—
  editBudget,             // ç¼–è¾‘é¢„ç®—

  // æ•°æ®æŸ¥çœ‹
  viewAllTransactions,    // æŸ¥çœ‹æ‰€æœ‰äº¤æ˜“
  viewStatistics,         // æŸ¥çœ‹ç»Ÿè®¡æ•°æ®
  exportData,             // å¯¼å‡ºæ•°æ®
}

/// è§’è‰²æƒé™æ˜ å°„
extension MemberRolePermissions on MemberRole {
  Set<LedgerPermission> get permissions {
    switch (this) {
      case MemberRole.owner:
        return LedgerPermission.values.toSet();

      case MemberRole.admin:
        return LedgerPermission.values.toSet()
          ..remove(LedgerPermission.deleteLedger);

      case MemberRole.member:
        return {
          LedgerPermission.createTransaction,
          LedgerPermission.editOwnTransaction,
          LedgerPermission.deleteOwnTransaction,
          LedgerPermission.viewBudget,
          LedgerPermission.viewAllTransactions,
          LedgerPermission.viewStatistics,
        };

      case MemberRole.viewer:
        return {
          LedgerPermission.viewAllTransactions,
          LedgerPermission.viewStatistics,
        };
    }
  }

  bool hasPermission(LedgerPermission permission) {
    return permissions.contains(permission);
  }
}

/// è´¦æœ¬æˆå‘˜
class LedgerMember {
  final String id;
  final String userId;
  final String? nickname;         // åœ¨è´¦æœ¬ä¸­çš„æ˜µç§°
  final String? avatarUrl;
  final MemberRole role;
  final DateTime joinedAt;
  final String? invitedBy;        // é‚€è¯·äººID
  final MemberSettings settings;  // ä¸ªäººè®¾ç½®

  LedgerMember({
    String? id,
    required this.userId,
    this.nickname,
    this.avatarUrl,
    required this.role,
    required this.joinedAt,
    this.invitedBy,
    MemberSettings? settings,
  }) : id = id ?? generateUuid(),
       settings = settings ?? MemberSettings();

  /// æ˜¾ç¤ºåç§°
  String get displayName => nickname ?? 'æˆå‘˜';
}

/// æˆå‘˜ä¸ªäººè®¾ç½®
class MemberSettings {
  final bool receiveNotifications;   // æ¥æ”¶é€šçŸ¥
  final bool showInRanking;          // æ˜¾ç¤ºåœ¨æ’è¡Œä¸­
  final VisibilityLevel defaultVisibility;  // é»˜è®¤å¯è§æ€§

  MemberSettings({
    this.receiveNotifications = true,
    this.showInRanking = true,
    this.defaultVisibility = VisibilityLevel.allMembers,
  });
}
```

#### 13.2.2 é‚€è¯·æœºåˆ¶

```dart
/// é‚€è¯·æœåŠ¡
class InvitationService {
  final InvitationRepository _repository;
  final LedgerService _ledgerService;
  final NotificationService _notificationService;

  /// åˆ›å»ºé‚€è¯·é“¾æ¥
  Future<Invitation> createInvitation({
    required String ledgerId,
    MemberRole role = MemberRole.member,
    Duration? expiresIn,
    int? maxUses,
  }) async {
    final ledger = await _ledgerService.getLedger(ledgerId);
    final userId = AuthService().currentUserId;

    // æ£€æŸ¥æƒé™
    if (!ledger.hasPermission(userId, LedgerPermission.inviteMember)) {
      throw NoPermissionException('æ— æƒé‚€è¯·æˆå‘˜');
    }

    final invitation = Invitation(
      id: generateUuid(),
      ledgerId: ledgerId,
      ledgerName: ledger.name,
      inviterId: userId,
      role: role,
      createdAt: DateTime.now(),
      expiresAt: expiresIn != null
          ? DateTime.now().add(expiresIn)
          : DateTime.now().add(const Duration(days: 7)),
      maxUses: maxUses,
      usedCount: 0,
      status: InvitationStatus.active,
    );

    await _repository.create(invitation);
    return invitation;
  }

  /// ç”Ÿæˆé‚€è¯·äºŒç»´ç æ•°æ®
  String generateQRCodeData(Invitation invitation) {
    return 'aibook://invite/${invitation.id}';
  }

  /// ç”Ÿæˆåˆ†äº«æ–‡æ¡ˆ
  String generateShareText(Invitation invitation) {
    return 'é‚€è¯·ä½ åŠ å…¥ \${invitation.ledgerName} è´¦æœ¬\\n\\n'
        'ç‚¹å‡»é“¾æ¥åŠ å…¥ï¼šhttps://aibook.app/invite/\${invitation.id}\\n\\n'
        'æˆ–åœ¨AIè®°è´¦Appä¸­æ‰«æäºŒç»´ç åŠ å…¥';
  }

  /// æ¥å—é‚€è¯·
  Future<void> acceptInvitation(String invitationId) async {
    final invitation = await _repository.getById(invitationId);
    if (invitation == null) {
      throw InvitationNotFoundException();
    }

    // éªŒè¯é‚€è¯·æœ‰æ•ˆæ€§
    _validateInvitation(invitation);

    final userId = AuthService().currentUserId;

    // æ£€æŸ¥æ˜¯å¦å·²æ˜¯æˆå‘˜
    final ledger = await _ledgerService.getLedger(invitation.ledgerId);
    if (ledger.members.any((m) => m.userId == userId)) {
      throw AlreadyMemberException();
    }

    // æ·»åŠ æˆå‘˜
    final member = LedgerMember(
      userId: userId,
      role: invitation.role,
      joinedAt: DateTime.now(),
      invitedBy: invitation.inviterId,
    );

    await _ledgerService.addMember(invitation.ledgerId, member);

    // æ›´æ–°é‚€è¯·ä½¿ç”¨æ¬¡æ•°
    await _repository.incrementUsedCount(invitationId);

    // é€šçŸ¥é‚€è¯·äºº
    await _notificationService.send(
      invitation.inviterId,
      NotificationType.memberJoined,
      {
        'ledgerName': invitation.ledgerName,
        'memberName': AuthService().currentUser?.displayName,
      },
    );
  }

  void _validateInvitation(Invitation invitation) {
    if (invitation.status != InvitationStatus.active) {
      throw InvitationExpiredException();
    }

    if (invitation.expiresAt.isBefore(DateTime.now())) {
      throw InvitationExpiredException();
    }

    if (invitation.maxUses != null &&
        invitation.usedCount >= invitation.maxUses!) {
      throw InvitationExhaustedException();
    }
  }
}

/// é‚€è¯·å®ä½“
class Invitation {
  final String id;
  final String ledgerId;
  final String ledgerName;
  final String inviterId;
  final MemberRole role;
  final DateTime createdAt;
  final DateTime expiresAt;
  final int? maxUses;
  final int usedCount;
  final InvitationStatus status;

  Invitation({
    required this.id,
    required this.ledgerId,
    required this.ledgerName,
    required this.inviterId,
    required this.role,
    required this.createdAt,
    required this.expiresAt,
    this.maxUses,
    required this.usedCount,
    required this.status,
  });

  bool get isValid =>
      status == InvitationStatus.active &&
      expiresAt.isAfter(DateTime.now()) &&
      (maxUses == null || usedCount < maxUses!);
}

enum InvitationStatus {
  active,
  expired,
  revoked,
}
```

### 13.3 å®¶åº­é¢„ç®—åä½œ

#### 13.3.1 å®¶åº­é¢„ç®—åˆ†é…æ¨¡å‹

```dart
/// å®¶åº­é¢„ç®—åˆ†é…ç­–ç•¥
enum FamilyBudgetStrategy {
  unified,      // ç»Ÿä¸€é¢„ç®—ï¼šå®¶åº­å…±ç”¨ä¸€ä¸ªé¢„ç®—æ± 
  perMember,    // æˆå‘˜é…é¢ï¼šæ¯ä¸ªæˆå‘˜æœ‰ç‹¬ç«‹é…é¢
  perCategory,  // åˆ†ç±»è´Ÿè´£ï¼šä¸åŒæˆå‘˜è´Ÿè´£ä¸åŒåˆ†ç±»
  hybrid,       // æ··åˆæ¨¡å¼ï¼šéƒ¨åˆ†ç»Ÿä¸€+éƒ¨åˆ†ç‹¬ç«‹
}

/// å®¶åº­é¢„ç®—
class FamilyBudget {
  final String id;
  final String ledgerId;
  final String period;            // é¢„ç®—å‘¨æœŸ (2026-01)
  final FamilyBudgetStrategy strategy;
  final double totalBudget;       // æ€»é¢„ç®—
  final Map<String, MemberBudget> memberBudgets;  // æˆå‘˜é¢„ç®—
  final Map<String, CategoryBudget> categoryBudgets;  // åˆ†ç±»é¢„ç®—
  final FamilyBudgetRules rules;

  FamilyBudget({
    required this.id,
    required this.ledgerId,
    required this.period,
    required this.strategy,
    required this.totalBudget,
    required this.memberBudgets,
    required this.categoryBudgets,
    required this.rules,
  });

  /// è·å–æˆå‘˜å‰©ä½™é¢„ç®—
  double getMemberRemaining(String userId) {
    final memberBudget = memberBudgets[userId];
    if (memberBudget == null) return 0;
    return memberBudget.allocated - memberBudget.spent;
  }

  /// è·å–å®¶åº­æ€»ä½“å‰©ä½™
  double get totalRemaining {
    final totalSpent = memberBudgets.values
        .fold(0.0, (sum, m) => sum + m.spent);
    return totalBudget - totalSpent;
  }

  /// è·å–é¢„ç®—ä½¿ç”¨ç™¾åˆ†æ¯”
  double get usagePercentage {
    if (totalBudget == 0) return 0;
    return (totalBudget - totalRemaining) / totalBudget * 100;
  }
}

/// æˆå‘˜é¢„ç®—
class MemberBudget {
  final String memberId;
  final double allocated;         // åˆ†é…é¢åº¦
  final double spent;             // å·²ä½¿ç”¨
  final Map<String, double> categorySpent;  // å„åˆ†ç±»æ”¯å‡º

  MemberBudget({
    required this.memberId,
    required this.allocated,
    required this.spent,
    required this.categorySpent,
  });

  double get remaining => allocated - spent;
  double get usagePercentage => allocated > 0 ? spent / allocated * 100 : 0;
}

/// å®¶åº­é¢„ç®—è§„åˆ™
class FamilyBudgetRules {
  final bool allowOverspend;          // å…è®¸è¶…æ”¯
  final double? overspendLimit;       // è¶…æ”¯ä¸Šé™
  final bool requireApprovalForLarge; // å¤§é¢æ”¯å‡ºéœ€å®¡æ‰¹
  final double? largeExpenseThreshold;// å¤§é¢æ”¯å‡ºé˜ˆå€¼
  final bool notifyOnThreshold;       // è¾¾åˆ°é˜ˆå€¼æ—¶é€šçŸ¥
  final List<int> thresholdPercentages;  // é€šçŸ¥é˜ˆå€¼ [50, 80, 100]

  FamilyBudgetRules({
    this.allowOverspend = false,
    this.overspendLimit,
    this.requireApprovalForLarge = false,
    this.largeExpenseThreshold,
    this.notifyOnThreshold = true,
    this.thresholdPercentages = const [50, 80, 100],
  });
}
```

#### 13.3.2 å®¶åº­é¢„ç®—æœåŠ¡

```dart
/// å®¶åº­é¢„ç®—æœåŠ¡
class FamilyBudgetService {
  final FamilyBudgetRepository _repository;
  final LedgerService _ledgerService;
  final NotificationService _notificationService;

  /// åˆ›å»ºå®¶åº­é¢„ç®—
  Future<FamilyBudget> createBudget({
    required String ledgerId,
    required String period,
    required double totalBudget,
    required FamilyBudgetStrategy strategy,
    Map<String, double>? memberAllocations,
    Map<String, double>? categoryAllocations,
    FamilyBudgetRules? rules,
  }) async {
    final ledger = await _ledgerService.getLedger(ledgerId);

    // æ ¹æ®ç­–ç•¥åˆå§‹åŒ–æˆå‘˜é¢„ç®—
    final memberBudgets = <String, MemberBudget>{};

    switch (strategy) {
      case FamilyBudgetStrategy.unified:
        // ç»Ÿä¸€é¢„ç®—ï¼šæ‰€æœ‰æˆå‘˜å…±äº«
        for (final member in ledger.members) {
          memberBudgets[member.userId] = MemberBudget(
            memberId: member.userId,
            allocated: totalBudget,  // å…±äº«æ€»é¢
            spent: 0,
            categorySpent: {},
          );
        }
        break;

      case FamilyBudgetStrategy.perMember:
        // æˆå‘˜é…é¢ï¼šæŒ‰åˆ†é…æ¯”ä¾‹
        if (memberAllocations == null) {
          // å¹³å‡åˆ†é…
          final perMember = totalBudget / ledger.members.length;
          for (final member in ledger.members) {
            memberBudgets[member.userId] = MemberBudget(
              memberId: member.userId,
              allocated: perMember,
              spent: 0,
              categorySpent: {},
            );
          }
        } else {
          for (final entry in memberAllocations.entries) {
            memberBudgets[entry.key] = MemberBudget(
              memberId: entry.key,
              allocated: entry.value,
              spent: 0,
              categorySpent: {},
            );
          }
        }
        break;

      // ... å…¶ä»–ç­–ç•¥
    }

    final budget = FamilyBudget(
      id: generateUuid(),
      ledgerId: ledgerId,
      period: period,
      strategy: strategy,
      totalBudget: totalBudget,
      memberBudgets: memberBudgets,
      categoryBudgets: {},
      rules: rules ?? FamilyBudgetRules(),
    );

    await _repository.create(budget);

    // é€šçŸ¥æ‰€æœ‰æˆå‘˜
    await _notifyBudgetCreated(ledger, budget);

    return budget;
  }

  /// è®°å½•æ”¯å‡ºæ—¶æ›´æ–°é¢„ç®—
  Future<BudgetUpdateResult> recordExpense({
    required String ledgerId,
    required String memberId,
    required double amount,
    required String categoryId,
  }) async {
    final budget = await _repository.getCurrentBudget(ledgerId);
    if (budget == null) {
      return BudgetUpdateResult(success: true, alerts: []);
    }

    final memberBudget = budget.memberBudgets[memberId];
    if (memberBudget == null) {
      return BudgetUpdateResult(success: true, alerts: []);
    }

    // æ›´æ–°æ”¯å‡º
    final newSpent = memberBudget.spent + amount;
    final newCategorySpent = Map<String, double>.from(memberBudget.categorySpent);
    newCategorySpent[categoryId] = (newCategorySpent[categoryId] ?? 0) + amount;

    await _repository.updateMemberSpent(
      budget.id,
      memberId,
      newSpent,
      newCategorySpent,
    );

    // æ£€æŸ¥é¢„ç®—å‘Šè­¦
    final alerts = await _checkBudgetAlerts(budget, memberId, newSpent);

    return BudgetUpdateResult(
      success: true,
      alerts: alerts,
      newRemaining: memberBudget.allocated - newSpent,
    );
  }

  /// æ£€æŸ¥é¢„ç®—å‘Šè­¦
  Future<List<BudgetAlert>> _checkBudgetAlerts(
    FamilyBudget budget,
    String memberId,
    double newSpent,
  ) async {
    final alerts = <BudgetAlert>[];
    final memberBudget = budget.memberBudgets[memberId]!;
    final usagePercent = newSpent / memberBudget.allocated * 100;

    for (final threshold in budget.rules.thresholdPercentages) {
      final previousPercent = memberBudget.spent / memberBudget.allocated * 100;

      // åˆšåˆšè¶Šè¿‡é˜ˆå€¼
      if (previousPercent < threshold && usagePercent >= threshold) {
        final alert = BudgetAlert(
          type: threshold >= 100
              ? BudgetAlertType.exceeded
              : BudgetAlertType.threshold,
          threshold: threshold,
          currentUsage: usagePercent,
          memberId: memberId,
        );
        alerts.add(alert);

        // å‘é€é€šçŸ¥
        if (budget.rules.notifyOnThreshold) {
          await _notifyBudgetAlert(budget, memberId, alert);
        }
      }
    }

    return alerts;
  }

  Future<void> _notifyBudgetAlert(
    FamilyBudget budget,
    String memberId,
    BudgetAlert alert,
  ) async {
    final ledger = await _ledgerService.getLedger(budget.ledgerId);

    // é€šçŸ¥æ‰€æœ‰ç®¡ç†å‘˜
    for (final member in ledger.members) {
      if (member.role == MemberRole.owner ||
          member.role == MemberRole.admin) {
        await _notificationService.send(
          member.userId,
          NotificationType.budgetAlert,
          {
            'ledgerName': ledger.name,
            'alertType': alert.type.name,
            'threshold': alert.threshold,
            'currentUsage': alert.currentUsage.toStringAsFixed(1),
          },
        );
      }
    }
  }
}

/// é¢„ç®—æ›´æ–°ç»“æœ
class BudgetUpdateResult {
  final bool success;
  final List<BudgetAlert> alerts;
  final double? newRemaining;

  BudgetUpdateResult({
    required this.success,
    required this.alerts,
    this.newRemaining,
  });
}

/// é¢„ç®—å‘Šè­¦
class BudgetAlert {
  final BudgetAlertType type;
  final int threshold;
  final double currentUsage;
  final String memberId;

  BudgetAlert({
    required this.type,
    required this.threshold,
    required this.currentUsage,
    required this.memberId,
  });
}

enum BudgetAlertType {
  threshold,    // è¾¾åˆ°é˜ˆå€¼
  exceeded,     // è¶…æ”¯
  largeExpense, // å¤§é¢æ”¯å‡º
}
```

### 13.4 äº¤æ˜“åä½œä¸åˆ†æ‘Š

#### 13.4.1 äº¤æ˜“å¯è§æ€§æ§åˆ¶

```dart
/// å®¶åº­äº¤æ˜“æ‰©å±•
class FamilyTransaction extends Transaction {
  final String ledgerId;
  final VisibilityLevel visibility;
  final List<String>? visibleToMembers;  // è‡ªå®šä¹‰å¯è§æˆå‘˜
  final SplitInfo? splitInfo;            // åˆ†æ‘Šä¿¡æ¯

  FamilyTransaction({
    required super.id,
    required super.amount,
    required super.categoryId,
    required super.createdBy,
    required super.createdAt,
    required this.ledgerId,
    this.visibility = VisibilityLevel.allMembers,
    this.visibleToMembers,
    this.splitInfo,
    // ... å…¶ä»–å­—æ®µ
  });

  /// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯è§æ­¤äº¤æ˜“
  bool isVisibleTo(String userId, MemberRole userRole) {
    // åˆ›å»ºè€…æ€»æ˜¯å¯è§
    if (createdBy == userId) return true;

    // æ‰€æœ‰è€…å’Œç®¡ç†å‘˜å¯è§å…¨éƒ¨
    if (userRole == MemberRole.owner || userRole == MemberRole.admin) {
      return true;
    }

    switch (visibility) {
      case VisibilityLevel.private:
        return false;
      case VisibilityLevel.allMembers:
        return true;
      case VisibilityLevel.adminsOnly:
        return false;
      case VisibilityLevel.custom:
        return visibleToMembers?.contains(userId) ?? false;
    }
  }
}
```

#### 13.4.2 AAåˆ†æ‘Šç³»ç»Ÿ

```dart
/// åˆ†æ‘Šä¿¡æ¯
class SplitInfo {
  final SplitType type;
  final List<SplitParticipant> participants;
  final SplitStatus status;

  SplitInfo({
    required this.type,
    required this.participants,
    required this.status,
  });

  /// è·å–æ€»é‡‘é¢
  double get totalAmount =>
      participants.fold(0.0, (sum, p) => sum + p.amount);

  /// è·å–å·²ç»“ç®—é‡‘é¢
  double get settledAmount =>
      participants.where((p) => p.isSettled).fold(0.0, (sum, p) => sum + p.amount);

  /// æ˜¯å¦å…¨éƒ¨ç»“ç®—
  bool get isFullySettled =>
      participants.every((p) => p.isSettled || p.isPayer);
}

/// åˆ†æ‘Šç±»å‹
enum SplitType {
  equal,        // å¹³å‡åˆ†æ‘Š
  percentage,   // æŒ‰æ¯”ä¾‹åˆ†æ‘Š
  exact,        // ç²¾ç¡®é‡‘é¢
  shares,       // æŒ‰ä»½æ•°
}

/// åˆ†æ‘Šå‚ä¸è€…
class SplitParticipant {
  final String memberId;
  final String memberName;
  final double amount;        // åº”ä»˜é‡‘é¢
  final double? percentage;   // åˆ†æ‘Šæ¯”ä¾‹
  final int? shares;          // ä»½æ•°
  final bool isPayer;         // æ˜¯å¦ä¸ºä»˜æ¬¾äºº
  final bool isSettled;       // æ˜¯å¦å·²ç»“ç®—
  final DateTime? settledAt;

  SplitParticipant({
    required this.memberId,
    required this.memberName,
    required this.amount,
    this.percentage,
    this.shares,
    this.isPayer = false,
    this.isSettled = false,
    this.settledAt,
  });
}

enum SplitStatus {
  pending,      // å¾…ç¡®è®¤
  confirmed,    // å·²ç¡®è®¤
  settling,     // ç»“ç®—ä¸­
  settled,      // å·²ç»“ç®—
}

/// åˆ†æ‘ŠæœåŠ¡
class SplitService {
  final TransactionRepository _transactionRepository;
  final NotificationService _notificationService;
  final LedgerService _ledgerService;

  /// åˆ›å»ºåˆ†æ‘Šäº¤æ˜“
  Future<FamilyTransaction> createSplitTransaction({
    required String ledgerId,
    required double totalAmount,
    required String categoryId,
    required String description,
    required SplitType splitType,
    required List<String> participantIds,
    String? payerId,
    Map<String, double>? exactAmounts,
    Map<String, int>? shares,
  }) async {
    final ledger = await _ledgerService.getLedger(ledgerId);
    final currentUserId = AuthService().currentUserId;
    final actualPayerId = payerId ?? currentUserId;

    // è®¡ç®—æ¯äººåº”ä»˜é‡‘é¢
    final participants = _calculateSplit(
      totalAmount: totalAmount,
      splitType: splitType,
      participantIds: participantIds,
      payerId: actualPayerId,
      ledger: ledger,
      exactAmounts: exactAmounts,
      shares: shares,
    );

    final transaction = FamilyTransaction(
      id: generateUuid(),
      amount: totalAmount,
      categoryId: categoryId,
      description: description,
      createdBy: currentUserId,
      createdAt: DateTime.now(),
      ledgerId: ledgerId,
      visibility: VisibilityLevel.allMembers,
      splitInfo: SplitInfo(
        type: splitType,
        participants: participants,
        status: SplitStatus.pending,
      ),
    );

    await _transactionRepository.create(transaction);

    // é€šçŸ¥å‚ä¸è€…
    for (final participant in participants) {
      if (!participant.isPayer) {
        await _notificationService.send(
          participant.memberId,
          NotificationType.splitRequest,
          {
            'amount': participant.amount,
            'description': description,
            'payerName': ledger.members
                .firstWhere((m) => m.userId == actualPayerId)
                .displayName,
          },
        );
      }
    }

    return transaction;
  }

  List<SplitParticipant> _calculateSplit({
    required double totalAmount,
    required SplitType splitType,
    required List<String> participantIds,
    required String payerId,
    required Ledger ledger,
    Map<String, double>? exactAmounts,
    Map<String, int>? shares,
  }) {
    final participants = <SplitParticipant>[];

    switch (splitType) {
      case SplitType.equal:
        final perPerson = totalAmount / participantIds.length;
        for (final id in participantIds) {
          final member = ledger.members.firstWhere((m) => m.userId == id);
          participants.add(SplitParticipant(
            memberId: id,
            memberName: member.displayName,
            amount: perPerson,
            percentage: 100 / participantIds.length,
            isPayer: id == payerId,
            isSettled: id == payerId,  // ä»˜æ¬¾äººè‡ªåŠ¨ç»“ç®—
          ));
        }
        break;

      case SplitType.exact:
        for (final id in participantIds) {
          final member = ledger.members.firstWhere((m) => m.userId == id);
          final amount = exactAmounts?[id] ?? 0;
          participants.add(SplitParticipant(
            memberId: id,
            memberName: member.displayName,
            amount: amount,
            isPayer: id == payerId,
            isSettled: id == payerId,
          ));
        }
        break;

      case SplitType.shares:
        final totalShares = shares?.values.fold(0, (a, b) => a + b) ?? participantIds.length;
        for (final id in participantIds) {
          final member = ledger.members.firstWhere((m) => m.userId == id);
          final memberShares = shares?[id] ?? 1;
          final amount = totalAmount * memberShares / totalShares;
          participants.add(SplitParticipant(
            memberId: id,
            memberName: member.displayName,
            amount: amount,
            shares: memberShares,
            isPayer: id == payerId,
            isSettled: id == payerId,
          ));
        }
        break;

      default:
        break;
    }

    return participants;
  }

  /// ç¡®è®¤åˆ†æ‘Šï¼ˆå‚ä¸è€…ç¡®è®¤è‡ªå·±çš„ä»½é¢ï¼‰
  Future<void> confirmSplit(String transactionId, String memberId) async {
    await _transactionRepository.updateSplitParticipantStatus(
      transactionId,
      memberId,
      isSettled: true,
      settledAt: DateTime.now(),
    );

    // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨ç»“ç®—
    final transaction = await _transactionRepository.getById(transactionId);
    if (transaction?.splitInfo?.isFullySettled ?? false) {
      await _transactionRepository.updateSplitStatus(
        transactionId,
        SplitStatus.settled,
      );
    }
  }
}
```

### 13.5 å®¶åº­ç»Ÿè®¡ä¸æŠ¥è¡¨

#### 13.5.1 å®¶åº­è´¢åŠ¡çœ‹æ¿

```dart
/// å®¶åº­è´¢åŠ¡çœ‹æ¿æ•°æ®
class FamilyDashboardData {
  final String ledgerId;
  final String period;
  final FamilySummary summary;
  final List<MemberContribution> memberContributions;
  final List<CategoryBreakdown> categoryBreakdown;
  final List<TrendPoint> spendingTrend;
  final List<BudgetStatus> budgetStatuses;
  final List<PendingSplit> pendingSplits;

  FamilyDashboardData({
    required this.ledgerId,
    required this.period,
    required this.summary,
    required this.memberContributions,
    required this.categoryBreakdown,
    required this.spendingTrend,
    required this.budgetStatuses,
    required this.pendingSplits,
  });
}

/// å®¶åº­æ±‡æ€»
class FamilySummary {
  final double totalIncome;
  final double totalExpense;
  final double netSavings;
  final double savingsRate;
  final int transactionCount;
  final double avgDailyExpense;

  FamilySummary({
    required this.totalIncome,
    required this.totalExpense,
    required this.netSavings,
    required this.savingsRate,
    required this.transactionCount,
    required this.avgDailyExpense,
  });
}

/// æˆå‘˜è´¡çŒ®
class MemberContribution {
  final String memberId;
  final String memberName;
  final String? avatarUrl;
  final double income;
  final double expense;
  final int transactionCount;
  final double contributionPercentage;  // æ”¯å‡ºå æ¯”
  final List<String> topCategories;     // ä¸»è¦æ”¯å‡ºåˆ†ç±»

  MemberContribution({
    required this.memberId,
    required this.memberName,
    this.avatarUrl,
    required this.income,
    required this.expense,
    required this.transactionCount,
    required this.contributionPercentage,
    required this.topCategories,
  });
}

/// å®¶åº­çœ‹æ¿æœåŠ¡
class FamilyDashboardService {
  final TransactionRepository _transactionRepository;
  final FamilyBudgetService _budgetService;
  final LedgerService _ledgerService;

  /// è·å–å®¶åº­çœ‹æ¿æ•°æ®
  Future<FamilyDashboardData> getDashboardData({
    required String ledgerId,
    required String period,
  }) async {
    final ledger = await _ledgerService.getLedger(ledgerId);
    final transactions = await _transactionRepository.getByLedgerAndPeriod(
      ledgerId,
      period,
    );

    // è®¡ç®—æ±‡æ€»
    final summary = _calculateSummary(transactions);

    // è®¡ç®—æˆå‘˜è´¡çŒ®
    final memberContributions = _calculateMemberContributions(
      transactions,
      ledger.members,
    );

    // åˆ†ç±»åˆ†å¸ƒ
    final categoryBreakdown = _calculateCategoryBreakdown(transactions);

    // æ”¯å‡ºè¶‹åŠ¿
    final spendingTrend = _calculateSpendingTrend(transactions, period);

    // é¢„ç®—çŠ¶æ€
    final budgetStatuses = await _getBudgetStatuses(ledgerId, period);

    // å¾…å¤„ç†åˆ†æ‘Š
    final pendingSplits = await _getPendingSplits(ledgerId);

    return FamilyDashboardData(
      ledgerId: ledgerId,
      period: period,
      summary: summary,
      memberContributions: memberContributions,
      categoryBreakdown: categoryBreakdown,
      spendingTrend: spendingTrend,
      budgetStatuses: budgetStatuses,
      pendingSplits: pendingSplits,
    );
  }

  FamilySummary _calculateSummary(List<FamilyTransaction> transactions) {
    double totalIncome = 0;
    double totalExpense = 0;

    for (final t in transactions) {
      if (t.type == TransactionType.income) {
        totalIncome += t.amount;
      } else {
        totalExpense += t.amount;
      }
    }

    final netSavings = totalIncome - totalExpense;
    final savingsRate = totalIncome > 0 ? netSavings / totalIncome * 100 : 0;

    // è®¡ç®—æ—¥å‡ï¼ˆå‡è®¾ä¸€ä¸ªæœˆ30å¤©ï¼‰
    final avgDailyExpense = totalExpense / 30;

    return FamilySummary(
      totalIncome: totalIncome,
      totalExpense: totalExpense,
      netSavings: netSavings,
      savingsRate: savingsRate,
      transactionCount: transactions.length,
      avgDailyExpense: avgDailyExpense,
    );
  }

  List<MemberContribution> _calculateMemberContributions(
    List<FamilyTransaction> transactions,
    List<LedgerMember> members,
  ) {
    final contributions = <String, MemberContribution>{};

    // åˆå§‹åŒ–æ‰€æœ‰æˆå‘˜
    for (final member in members) {
      contributions[member.userId] = MemberContribution(
        memberId: member.userId,
        memberName: member.displayName,
        avatarUrl: member.avatarUrl,
        income: 0,
        expense: 0,
        transactionCount: 0,
        contributionPercentage: 0,
        topCategories: [],
      );
    }

    // ç»Ÿè®¡å„æˆå‘˜æ•°æ®
    final memberCategorySpend = <String, Map<String, double>>{};

    for (final t in transactions) {
      final current = contributions[t.createdBy];
      if (current == null) continue;

      final categorySpend = memberCategorySpend[t.createdBy] ?? {};

      if (t.type == TransactionType.income) {
        contributions[t.createdBy] = MemberContribution(
          memberId: current.memberId,
          memberName: current.memberName,
          avatarUrl: current.avatarUrl,
          income: current.income + t.amount,
          expense: current.expense,
          transactionCount: current.transactionCount + 1,
          contributionPercentage: 0,
          topCategories: current.topCategories,
        );
      } else {
        categorySpend[t.categoryId] = (categorySpend[t.categoryId] ?? 0) + t.amount;
        memberCategorySpend[t.createdBy] = categorySpend;

        contributions[t.createdBy] = MemberContribution(
          memberId: current.memberId,
          memberName: current.memberName,
          avatarUrl: current.avatarUrl,
          income: current.income,
          expense: current.expense + t.amount,
          transactionCount: current.transactionCount + 1,
          contributionPercentage: 0,
          topCategories: current.topCategories,
        );
      }
    }

    // è®¡ç®—å æ¯”å’ŒTopåˆ†ç±»
    final totalExpense = contributions.values.fold(0.0, (sum, c) => sum + c.expense);

    return contributions.values.map((c) {
      final categorySpend = memberCategorySpend[c.memberId] ?? {};
      final sortedCategories = categorySpend.entries.toList()
        ..sort((a, b) => b.value.compareTo(a.value));
      final topCategories = sortedCategories.take(3).map((e) => e.key).toList();

      return MemberContribution(
        memberId: c.memberId,
        memberName: c.memberName,
        avatarUrl: c.avatarUrl,
        income: c.income,
        expense: c.expense,
        transactionCount: c.transactionCount,
        contributionPercentage: totalExpense > 0 ? c.expense / totalExpense * 100 : 0,
        topCategories: topCategories,
      );
    }).toList()
      ..sort((a, b) => b.expense.compareTo(a.expense));
  }

  // ... å…¶ä»–è¾…åŠ©æ–¹æ³•
}
```

### 13.6 å®¶åº­ç›®æ ‡ä¸æ¿€åŠ±

#### 13.6.1 å…±åŒå‚¨è“„ç›®æ ‡

```dart
/// å®¶åº­å‚¨è“„ç›®æ ‡
class FamilySavingsGoal {
  final String id;
  final String ledgerId;
  final String name;
  final String? emoji;
  final double targetAmount;
  final double currentAmount;
  final DateTime? deadline;
  final List<GoalContributor> contributors;
  final GoalStatus status;

  FamilySavingsGoal({
    required this.id,
    required this.ledgerId,
    required this.name,
    this.emoji,
    required this.targetAmount,
    required this.currentAmount,
    this.deadline,
    required this.contributors,
    required this.status,
  });

  double get progressPercentage =>
      targetAmount > 0 ? currentAmount / targetAmount * 100 : 0;

  int? get daysRemaining =>
      deadline?.difference(DateTime.now()).inDays;
}

/// ç›®æ ‡è´¡çŒ®è€…
class GoalContributor {
  final String memberId;
  final String memberName;
  final double contribution;
  final double percentage;

  GoalContributor({
    required this.memberId,
    required this.memberName,
    required this.contribution,
    required this.percentage,
  });
}

/// å®¶åº­ç›®æ ‡æœåŠ¡
class FamilyGoalService {
  final FamilyGoalRepository _repository;
  final NotificationService _notificationService;
  final LedgerService _ledgerService;

  /// åˆ›å»ºå®¶åº­ç›®æ ‡
  Future<FamilySavingsGoal> createGoal({
    required String ledgerId,
    required String name,
    required double targetAmount,
    String? emoji,
    DateTime? deadline,
  }) async {
    final goal = FamilySavingsGoal(
      id: generateUuid(),
      ledgerId: ledgerId,
      name: name,
      emoji: emoji ?? 'ğŸ¯',
      targetAmount: targetAmount,
      currentAmount: 0,
      deadline: deadline,
      contributors: [],
      status: GoalStatus.active,
    );

    await _repository.create(goal);

    // é€šçŸ¥æ‰€æœ‰æˆå‘˜
    final ledger = await _ledgerService.getLedger(ledgerId);
    for (final member in ledger.members) {
      await _notificationService.send(
        member.userId,
        NotificationType.goalCreated,
        {'goalName': name, 'targetAmount': targetAmount},
      );
    }

    return goal;
  }

  /// è´¡çŒ®é‡‘é¢
  Future<void> contribute({
    required String goalId,
    required double amount,
  }) async {
    final goal = await _repository.getById(goalId);
    if (goal == null) return;

    final userId = AuthService().currentUserId;
    await _repository.addContribution(goalId, userId, amount);

    // æ£€æŸ¥æ˜¯å¦è¾¾æˆç›®æ ‡
    final newAmount = goal.currentAmount + amount;
    if (newAmount >= goal.targetAmount) {
      await _celebrateGoalAchieved(goal);
    }
  }

  /// åº†ç¥ç›®æ ‡è¾¾æˆ
  Future<void> _celebrateGoalAchieved(FamilySavingsGoal goal) async {
    await _repository.updateStatus(goal.id, GoalStatus.achieved);

    final ledger = await _ledgerService.getLedger(goal.ledgerId);
    for (final member in ledger.members) {
      await _notificationService.send(
        member.userId,
        NotificationType.goalAchieved,
        {
          'goalName': goal.name,
          'targetAmount': goal.targetAmount,
          'emoji': goal.emoji,
        },
      );
    }
  }
}

enum GoalStatus {
  active,
  achieved,
  cancelled,
}
```

#### 13.6.2 å®¶åº­æ’è¡Œæ¦œä¸æ¿€åŠ±

```dart
/// å®¶åº­æ’è¡Œæ¦œ
class FamilyLeaderboard {
  final String ledgerId;
  final String period;
  final List<LeaderboardEntry> savingsRanking;      // å‚¨è“„æ’è¡Œ
  final List<LeaderboardEntry> recordingRanking;    // è®°è´¦å‹¤å¥‹åº¦
  final List<LeaderboardEntry> budgetCompliance;    // é¢„ç®—éµå®ˆåº¦
  final List<AchievementBadge> recentAchievements;  // è¿‘æœŸæˆå°±

  FamilyLeaderboard({
    required this.ledgerId,
    required this.period,
    required this.savingsRanking,
    required this.recordingRanking,
    required this.budgetCompliance,
    required this.recentAchievements,
  });
}

/// æ’è¡Œæ¦œæ¡ç›®
class LeaderboardEntry {
  final int rank;
  final String memberId;
  final String memberName;
  final String? avatarUrl;
  final double value;
  final String valueLabel;        // å¦‚ "Â¥3,200" æˆ– "98%"
  final int? changeFromLastPeriod;  // æ’åå˜åŒ–

  LeaderboardEntry({
    required this.rank,
    required this.memberId,
    required this.memberName,
    this.avatarUrl,
    required this.value,
    required this.valueLabel,
    this.changeFromLastPeriod,
  });
}

/// æˆå°±å¾½ç« 
class AchievementBadge {
  final String id;
  final String name;
  final String description;
  final String emoji;
  final String memberId;
  final String memberName;
  final DateTime earnedAt;

  AchievementBadge({
    required this.id,
    required this.name,
    required this.description,
    required this.emoji,
    required this.memberId,
    required this.memberName,
    required this.earnedAt,
  });
}

/// å®¶åº­æ’è¡Œæ¦œæœåŠ¡
class FamilyLeaderboardService {
  final TransactionRepository _transactionRepository;
  final FamilyBudgetService _budgetService;

  /// è·å–å®¶åº­æ’è¡Œæ¦œ
  Future<FamilyLeaderboard> getLeaderboard({
    required String ledgerId,
    required String period,
  }) async {
    // å‚¨è“„æ’è¡Œ
    final savingsRanking = await _calculateSavingsRanking(ledgerId, period);

    // è®°è´¦å‹¤å¥‹åº¦æ’è¡Œ
    final recordingRanking = await _calculateRecordingRanking(ledgerId, period);

    // é¢„ç®—éµå®ˆåº¦æ’è¡Œ
    final budgetCompliance = await _calculateBudgetCompliance(ledgerId, period);

    // è¿‘æœŸæˆå°±
    final recentAchievements = await _getRecentAchievements(ledgerId);

    return FamilyLeaderboard(
      ledgerId: ledgerId,
      period: period,
      savingsRanking: savingsRanking,
      recordingRanking: recordingRanking,
      budgetCompliance: budgetCompliance,
      recentAchievements: recentAchievements,
    );
  }

  /// é¢„å®šä¹‰çš„å®¶åº­æˆå°±
  static const familyAchievements = [
    {'id': 'first_family_record', 'name': 'å®¶åº­é¦–è´¦', 'emoji': 'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§'},
    {'id': 'savings_champion', 'name': 'å‚¨è“„å† å†›', 'emoji': 'ğŸ†'},
    {'id': 'budget_master', 'name': 'é¢„ç®—è¾¾äºº', 'emoji': 'ğŸ“Š'},
    {'id': 'recording_streak_7', 'name': 'è¿ç»­è®°è´¦7å¤©', 'emoji': 'ğŸ”¥'},
    {'id': 'goal_contributor', 'name': 'ç›®æ ‡è´¡çŒ®è€…', 'emoji': 'ğŸ¯'},
    {'id': 'family_saver', 'name': 'å®¶åº­ç†è´¢å¸ˆ', 'emoji': 'ğŸ’°'},
  ];

  // ... è¾…åŠ©æ–¹æ³•å®ç°
}
```

### 13.7 æ•°æ®åŒæ­¥ä¸å†²çªå¤„ç†

#### 13.7.1 å®æ—¶åŒæ­¥æœºåˆ¶

```dart
/// å®¶åº­è´¦æœ¬åŒæ­¥æœåŠ¡
class FamilyLedgerSyncService {
  final WebSocketService _wsService;
  final LocalDatabase _localDb;
  final ConflictResolver _conflictResolver;

  final StreamController<SyncEvent> _syncEvents = StreamController.broadcast();
  Stream<SyncEvent> get syncEvents => _syncEvents.stream;

  /// å¯åŠ¨è´¦æœ¬åŒæ­¥
  Future<void> startSync(String ledgerId) async {
    // å»ºç«‹WebSocketè¿æ¥
    await _wsService.connect('/ledger/$ledgerId/sync');

    // ç›‘å¬è¿œç¨‹å˜æ›´
    _wsService.onMessage.listen((message) {
      _handleRemoteChange(message);
    });

    // ç›‘å¬æœ¬åœ°å˜æ›´
    _localDb.watchChanges(ledgerId).listen((change) {
      _pushLocalChange(ledgerId, change);
    });
  }

  /// å¤„ç†è¿œç¨‹å˜æ›´
  Future<void> _handleRemoteChange(SyncMessage message) async {
    switch (message.type) {
      case SyncMessageType.transactionCreated:
        await _handleTransactionCreated(message.data);
        break;
      case SyncMessageType.transactionUpdated:
        await _handleTransactionUpdated(message.data);
        break;
      case SyncMessageType.transactionDeleted:
        await _handleTransactionDeleted(message.data);
        break;
      case SyncMessageType.memberJoined:
        await _handleMemberJoined(message.data);
        break;
      case SyncMessageType.budgetUpdated:
        await _handleBudgetUpdated(message.data);
        break;
    }

    _syncEvents.add(SyncEvent(
      type: SyncEventType.remoteChange,
      message: message,
    ));
  }

  /// æ¨é€æœ¬åœ°å˜æ›´
  Future<void> _pushLocalChange(String ledgerId, LocalChange change) async {
    try {
      await _wsService.send(SyncMessage(
        type: _mapChangeType(change.type),
        data: change.data,
        timestamp: DateTime.now(),
        clientId: DeviceInfo.deviceId,
      ));
    } catch (e) {
      // ç¦»çº¿æ—¶æš‚å­˜å˜æ›´
      await _localDb.queuePendingSync(change);
    }
  }

  /// å¤„ç†å†²çª
  Future<void> _handleConflict(
    LocalChange local,
    SyncMessage remote,
  ) async {
    final resolution = await _conflictResolver.resolve(local, remote);

    switch (resolution.strategy) {
      case ConflictStrategy.keepLocal:
        await _pushLocalChange(local.ledgerId, local);
        break;
      case ConflictStrategy.keepRemote:
        await _localDb.applyRemoteChange(remote);
        break;
      case ConflictStrategy.merge:
        await _localDb.applyMergedChange(resolution.mergedData);
        await _pushLocalChange(local.ledgerId, LocalChange(
          type: local.type,
          data: resolution.mergedData,
        ));
        break;
      case ConflictStrategy.askUser:
        _syncEvents.add(SyncEvent(
          type: SyncEventType.conflictDetected,
          conflict: ConflictInfo(local: local, remote: remote),
        ));
        break;
    }
  }
}

/// å†²çªè§£å†³å™¨
class ConflictResolver {
  /// è§£å†³å†²çª
  Future<ConflictResolution> resolve(
    LocalChange local,
    SyncMessage remote,
  ) async {
    // æ—¶é—´æˆ³æ¯”è¾ƒï¼šåè€…ä¼˜å…ˆ
    if (remote.timestamp.isAfter(local.timestamp)) {
      return ConflictResolution(strategy: ConflictStrategy.keepRemote);
    }

    // å¦‚æœæ˜¯åŒä¸€ç”¨æˆ·çš„å˜æ›´ï¼Œä¿ç•™æœ¬åœ°
    if (remote.data['userId'] == AuthService().currentUserId) {
      return ConflictResolution(strategy: ConflictStrategy.keepLocal);
    }

    // å°è¯•è‡ªåŠ¨åˆå¹¶ï¼ˆå¦‚é‡‘é¢ä¿®æ”¹ï¼‰
    if (_canAutoMerge(local, remote)) {
      final merged = _autoMerge(local.data, remote.data);
      return ConflictResolution(
        strategy: ConflictStrategy.merge,
        mergedData: merged,
      );
    }

    // æ— æ³•è‡ªåŠ¨è§£å†³ï¼Œè¯¢é—®ç”¨æˆ·
    return ConflictResolution(strategy: ConflictStrategy.askUser);
  }

  bool _canAutoMerge(LocalChange local, SyncMessage remote) {
    // æ£€æŸ¥æ˜¯å¦å¯ä»¥è‡ªåŠ¨åˆå¹¶
    // ä¾‹å¦‚ï¼šä¸åŒå­—æ®µçš„ä¿®æ”¹å¯ä»¥åˆå¹¶
    final localFields = local.data['modifiedFields'] as Set<String>?;
    final remoteFields = remote.data['modifiedFields'] as Set<String>?;

    if (localFields == null || remoteFields == null) return false;

    // å¦‚æœä¿®æ”¹çš„æ˜¯ä¸åŒå­—æ®µï¼Œå¯ä»¥åˆå¹¶
    return localFields.intersection(remoteFields).isEmpty;
  }

  Map<String, dynamic> _autoMerge(
    Map<String, dynamic> local,
    Map<String, dynamic> remote,
  ) {
    final merged = Map<String, dynamic>.from(remote);
    final localFields = local['modifiedFields'] as Set<String>;

    for (final field in localFields) {
      merged[field] = local[field];
    }

    return merged;
  }
}

enum ConflictStrategy {
  keepLocal,
  keepRemote,
  merge,
  askUser,
}

class ConflictResolution {
  final ConflictStrategy strategy;
  final Map<String, dynamic>? mergedData;

  ConflictResolution({
    required this.strategy,
    this.mergedData,
  });
}
```

### 13.8 éšç§ä¸å®‰å…¨

#### 13.8.1 å®¶åº­è´¦æœ¬éšç§è®¾è®¡

```dart
/// å®¶åº­éšç§è®¾ç½®
class FamilyPrivacySettings {
  final bool allowMembersToSeeEachOther;  // æˆå‘˜äº’ç›¸å¯è§
  final bool showMemberBalance;           // æ˜¾ç¤ºæˆå‘˜ä½™é¢
  final bool showMemberIncome;            // æ˜¾ç¤ºæˆå‘˜æ”¶å…¥
  final bool allowExportByMembers;        // å…è®¸æˆå‘˜å¯¼å‡ºæ•°æ®
  final List<String> hiddenCategories;    // å¯¹æ™®é€šæˆå‘˜éšè—çš„åˆ†ç±»

  FamilyPrivacySettings({
    this.allowMembersToSeeEachOther = true,
    this.showMemberBalance = false,
    this.showMemberIncome = false,
    this.allowExportByMembers = false,
    this.hiddenCategories = const [],
  });
}

/// æ•æ„Ÿäº¤æ˜“ä¿æŠ¤
class SensitiveTransactionGuard {
  /// æ£€æŸ¥äº¤æ˜“æ˜¯å¦åŒ…å«æ•æ„Ÿä¿¡æ¯
  bool isSensitive(Transaction transaction) {
    // æ£€æŸ¥åˆ†ç±»
    if (_sensitiveCategories.contains(transaction.categoryId)) {
      return true;
    }

    // æ£€æŸ¥æè¿°ä¸­çš„æ•æ„Ÿè¯
    if (_containsSensitiveWords(transaction.description)) {
      return true;
    }

    // æ£€æŸ¥é‡‘é¢æ˜¯å¦å¼‚å¸¸å¤§
    if (transaction.amount > _largeAmountThreshold) {
      return true;
    }

    return false;
  }

  static const _sensitiveCategories = [
    'medical',      // åŒ»ç–—
    'gift_private', // ç§äººç¤¼ç‰©
    'investment',   // æŠ•èµ„
  ];

  static const _sensitiveWords = [
    'ç¤¼ç‰©', 'æƒŠå–œ', 'ç§˜å¯†', 'ç§äºº',
  ];

  static const _largeAmountThreshold = 10000.0;

  bool _containsSensitiveWords(String? text) {
    if (text == null) return false;
    return _sensitiveWords.any((word) => text.contains(word));
  }
}
```

### 13.9 ä¸å…¶ä»–ç³»ç»Ÿçš„é›†æˆ

#### 13.9.1 é›†æˆç‚¹æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å®¶åº­è´¦æœ¬ç³»ç»Ÿé›†æˆç‚¹                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                             â”‚
â”‚  â”‚ å®¶åº­è´¦æœ¬ç³»ç»Ÿ â”‚                                                             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                                             â”‚
â”‚         â”‚                                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                          é›†æˆæ¥å£å±‚                                   â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚    â”‚
â”‚  â”‚  â”‚ è´¦æœ¬ä¸Šä¸‹æ–‡ â”‚ â”‚ æˆå‘˜ä¸Šä¸‹æ–‡â”‚ â”‚ æƒé™æ£€æŸ¥  â”‚ â”‚ æ•°æ®è¿‡æ»¤  â”‚ â”‚ é€šçŸ¥åˆ†å‘  â”‚  â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚           â”‚           â”‚           â”‚           â”‚                    â”‚
â”‚         â–¼           â–¼           â–¼           â–¼           â–¼                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  é’±é¾„ç³»ç»Ÿ â”‚ â”‚  é¢„ç®—ç³»ç»Ÿ â”‚ â”‚ ä¹ æƒ¯åŸ¹å…»  â”‚ â”‚ æ•°æ®å¯è§†åŒ–â”‚ â”‚ è¯­éŸ³äº¤äº’  â”‚          â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚  â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚  â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚  â”€â”€â”€â”€â”€â”€â”€â”€ â”‚          â”‚
â”‚  â”‚ å®¶åº­é’±é¾„  â”‚ â”‚ å®¶åº­é¢„ç®—  â”‚ â”‚ å…±åŒç›®æ ‡  â”‚ â”‚ æˆå‘˜å¯¹æ¯”  â”‚ â”‚ "å®¶åº­æ”¯å‡º"â”‚          â”‚
â”‚  â”‚ ç»Ÿè®¡      â”‚ â”‚ æˆå‘˜é…é¢  â”‚ â”‚ æ’è¡Œæ¦œ    â”‚ â”‚ å®¶åº­æŠ¥è¡¨  â”‚ â”‚ è¯­éŸ³å‘½ä»¤  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 13.9.2 ç»Ÿä¸€è´¦æœ¬ä¸Šä¸‹æ–‡

```dart
/// è´¦æœ¬ä¸Šä¸‹æ–‡ - å…¨å±€å¯ç”¨ï¼Œç¡®å®šå½“å‰æ“ä½œçš„è´¦æœ¬å’Œæƒé™
class LedgerContext {
  static final LedgerContext _instance = LedgerContext._internal();
  factory LedgerContext() => _instance;
  LedgerContext._internal();

  final LedgerService _ledgerService = LedgerService();

  /// å½“å‰è´¦æœ¬
  Ledger? get currentLedger => _ledgerService.currentLedger.value;

  /// å½“å‰ç”¨æˆ·åœ¨å½“å‰è´¦æœ¬çš„è§’è‰²
  MemberRole? get currentUserRole {
    final userId = AuthService().currentUserId;
    return currentLedger?.members
        .firstWhereOrNull((m) => m.userId == userId)
        ?.role;
  }

  /// æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æœ‰æŒ‡å®šæƒé™
  bool hasPermission(LedgerPermission permission) {
    return currentUserRole?.hasPermission(permission) ?? false;
  }

  /// æ˜¯å¦ä¸ºå…±äº«è´¦æœ¬
  bool get isSharedLedger => currentLedger?.isShared ?? false;

  /// è·å–å½“å‰è´¦æœ¬çš„æ‰€æœ‰æˆå‘˜
  List<LedgerMember> get members => currentLedger?.members ?? [];

  /// ç›‘å¬è´¦æœ¬å˜åŒ–
  Stream<Ledger?> get ledgerChanges =>
      _ledgerService.currentLedger.asStream();
}

/// è´¦æœ¬æ„ŸçŸ¥çš„æœåŠ¡åŸºç±»
abstract class LedgerAwareService {
  LedgerContext get ledgerContext => LedgerContext();

  /// ç¡®ä¿æœ‰æƒé™æ‰§è¡Œæ“ä½œ
  void ensurePermission(LedgerPermission permission) {
    if (!ledgerContext.hasPermission(permission)) {
      throw NoPermissionException();
    }
  }

  /// è·å–å½“å‰è´¦æœ¬ID
  String get currentLedgerId {
    final ledger = ledgerContext.currentLedger;
    if (ledger == null) throw NoActiveLedgerException();
    return ledger.id;
  }
}
```

### 13.10 ç›®æ ‡è¾¾æˆæ£€æµ‹

```dart
/// å®¶åº­è´¦æœ¬ç›®æ ‡æ£€æµ‹æœåŠ¡
class FamilyLedgerGoalChecker implements GoalChecker {
  final LedgerService _ledgerService;
  final FamilyBudgetService _budgetService;
  final FamilyGoalService _goalService;

  @override
  String get goalId => 'family_ledger_effectiveness';

  @override
  Future<GoalCheckResult> check() async {
    final checks = <GoalCheckItem>[];

    // æ£€æŸ¥1ï¼šå®¶åº­è´¦æœ¬åˆ›å»ºç‡
    final familyLedgers = await _ledgerService.getFamilyLedgers();
    checks.add(GoalCheckItem(
      name: 'å®¶åº­è´¦æœ¬æ•°',
      target: '>= 1',
      actual: '${familyLedgers.length}',
      passed: familyLedgers.isNotEmpty,
    ));

    // æ£€æŸ¥2ï¼šæˆå‘˜æ´»è·ƒåº¦
    for (final ledger in familyLedgers) {
      final activeMembers = await _getActiveMembers(ledger.id);
      checks.add(GoalCheckItem(
        name: '${ledger.name} æ´»è·ƒæˆå‘˜',
        target: '>= 2',
        actual: '$activeMembers',
        passed: activeMembers >= 2,
      ));
    }

    // æ£€æŸ¥3ï¼šé¢„ç®—éµå®ˆç‡
    final budgetCompliance = await _budgetService.getAverageCompliance();
    checks.add(GoalCheckItem(
      name: 'å®¶åº­é¢„ç®—éµå®ˆç‡',
      target: '>= 80%',
      actual: '${budgetCompliance.toStringAsFixed(1)}%',
      passed: budgetCompliance >= 80,
    ));

    // æ£€æŸ¥4ï¼šå…±åŒç›®æ ‡è¾¾æˆç‡
    final goalAchievementRate = await _goalService.getAchievementRate();
    checks.add(GoalCheckItem(
      name: 'å…±åŒç›®æ ‡è¾¾æˆç‡',
      target: '>= 70%',
      actual: '${goalAchievementRate.toStringAsFixed(1)}%',
      passed: goalAchievementRate >= 70,
    ));

    return GoalCheckResult(
      goalId: goalId,
      passed: checks.every((c) => c.passed),
      items: checks,
      checkedAt: DateTime.now(),
    );
  }

  Future<int> _getActiveMembers(String ledgerId) async {
    // ç»Ÿè®¡è¿‡å»30å¤©æœ‰è®°è´¦è¡Œä¸ºçš„æˆå‘˜æ•°
    // ...å®ç°ç•¥
    return 0;
  }
}
```

'''

def main():
    filepath = 'd:/code/ai-bookkeeping/docs/design/app_v2_design.md'

    with open(filepath, 'r', encoding='utf-8') as f:
        content = f.read()

    # åœ¨ç¬¬12ç« ï¼ˆæ•°æ®è”åŠ¨ä¸å¯è§†åŒ–ï¼‰ä¹‹åæ’å…¥æ–°ç« èŠ‚
    # åŸæ¥çš„13ç« åŠä¹‹åéœ€è¦é¡ºå»¶

    # æ‰¾åˆ°ç¬¬13ç« çš„ä½ç½®
    old_ch13 = '## 13. åœ°ç†ä½ç½®æ™ºèƒ½åŒ–åº”ç”¨'
    insert_pos = content.find(old_ch13)

    if insert_pos == -1:
        print("âŒ æœªæ‰¾åˆ°ç¬¬13ç« ä½ç½®")
        return

    # æ’å…¥æ–°ç« èŠ‚
    content = content[:insert_pos] + FAMILY_CHAPTER + '\n\n' + content[insert_pos:]
    print("âœ… æ’å…¥å®¶åº­è´¦æœ¬ç« èŠ‚")

    # æ›´æ–°åç»­ç« èŠ‚ç¼–å·ï¼š13->14, 14->15, ..., 26->27
    chapter_updates = [
        ('## 13. åœ°ç†ä½ç½®æ™ºèƒ½åŒ–åº”ç”¨', '## 14. åœ°ç†ä½ç½®æ™ºèƒ½åŒ–åº”ç”¨'),
        ('## 14. æŠ€æœ¯æ¶æ„è®¾è®¡', '## 15. æŠ€æœ¯æ¶æ„è®¾è®¡'),
        ('## 15. æ™ºèƒ½åŒ–æŠ€æœ¯æ–¹æ¡ˆ', '## 16. æ™ºèƒ½åŒ–æŠ€æœ¯æ–¹æ¡ˆ'),
        ('## 16. è‡ªå­¦ä¹ ä¸ååŒå­¦ä¹ ç³»ç»Ÿ', '## 17. è‡ªå­¦ä¹ ä¸ååŒå­¦ä¹ ç³»ç»Ÿ'),
        ('## 17. æ™ºèƒ½è¯­éŸ³äº¤äº’ç³»ç»Ÿ', '## 18. æ™ºèƒ½è¯­éŸ³äº¤äº’ç³»ç»Ÿ'),
        ('## 18. æ€§èƒ½è®¾è®¡ä¸ä¼˜åŒ–', '## 19. æ€§èƒ½è®¾è®¡ä¸ä¼˜åŒ–'),
        ('## 19. ç”¨æˆ·ä½“éªŒè®¾è®¡', '## 20. ç”¨æˆ·ä½“éªŒè®¾è®¡'),
        ('## 20. å›½é™…åŒ–ä¸æœ¬åœ°åŒ–', '## 21. å›½é™…åŒ–ä¸æœ¬åœ°åŒ–'),
        ('## 21. å®‰å…¨ä¸éšç§', '## 22. å®‰å…¨ä¸éšç§'),
        ('## 22. å¼‚å¸¸å¤„ç†ä¸å®¹é”™è®¾è®¡', '## 23. å¼‚å¸¸å¤„ç†ä¸å®¹é”™è®¾è®¡'),
        ('## 23. å¯æ‰©å±•æ€§ä¸æ¼”è¿›æ¶æ„', '## 24. å¯æ‰©å±•æ€§ä¸æ¼”è¿›æ¶æ„'),
        ('## 24. å¯è§‚æµ‹æ€§ä¸ç›‘æ§', '## 25. å¯è§‚æµ‹æ€§ä¸ç›‘æ§'),
        ('## 25. ç‰ˆæœ¬è¿ç§»ç­–ç•¥', '## 26. ç‰ˆæœ¬è¿ç§»ç­–ç•¥'),
        ('## 26. å®æ–½è·¯çº¿å›¾', '## 27. å®æ–½è·¯çº¿å›¾'),
    ]

    for old, new in chapter_updates:
        content = content.replace(old, new)
        print(f"âœ… {old} -> {new}")

    # ä¿å­˜
    with open(filepath, 'w', encoding='utf-8') as f:
        f.write(content)

    print("\nâœ… å®¶åº­è´¦æœ¬ç« èŠ‚æ·»åŠ å®Œæˆï¼")
    print("   - æ–°å¢ï¼šç¬¬13ç«  å®¶åº­è´¦æœ¬ä¸å¤šæˆå‘˜ç®¡ç†ç³»ç»Ÿ")
    print("   - åŸ13-26ç« é¡ºå»¶ä¸º14-27ç« ")

if __name__ == '__main__':
    main()
