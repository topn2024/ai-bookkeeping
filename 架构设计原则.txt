1. 单一职责原则
定义：一个模块 / 服务 / 组件只负责一个明确的功能，避免 “万能模块”。
落地场景：
记账 App 的「用户模块」只负责注册、登录、个人信息管理，不掺杂账单统计逻辑；
「统计模块」只处理数据计算，不直接操作数据库（由数据层统一处理）。
价值：降低模块耦合度，便于单独开发、测试、迭代，故障影响范围可控。
2. 高可用优先原则
定义：系统在面对硬件故障、网络波动、流量高峰时，仍能保持核心功能可用，核心指标是 可用性（SLA），比如 99.9% 意味着每月故障时间不超过 43 分钟。
落地场景：
记账 App 采用「双应用节点 + MySQL 主从 + Redis 主从」，避免单点故障；
关键接口（如账单录入）做幂等性设计，防止用户重复提交导致数据错误。
核心策略：冗余部署、故障自动切换、降级熔断、数据多副本备份。
3. 分层架构原则
定义：将系统按职责划分为接入层、应用层、缓存层、数据层、资源层等，层与层之间通过标准接口通信，禁止跨层调用。
落地场景：
记账 App 的分层：SLB 接入层 → 应用层（业务逻辑） → Redis 缓存层 → MySQL 数据层 → OSS 资源层；
应用层不能直接操作 OSS，必须通过资源层的 API 调用。
价值：架构清晰，每层可独立升级（如替换缓存组件不影响应用层），便于团队协作分工。
4. 性能与成本平衡原则
定义：性能优化不是 “无限堆砌资源”，而是在满足业务需求的前提下，用最低成本实现最优性能。
落地场景：
记账 App 10000 DAU 用「2 核 4G 双节点」即可，无需直接上 8 核 16G 服务器；
用 Redis 缓存热点数据（如账单列表），比升级数据库配置更省钱、效果更好。
核心策略：优先做非资源型优化（如 SQL 索引、缓存、异步处理），再考虑资源扩容。
5. 可扩展性原则
定义：系统支持功能扩展（新增模块）和规模扩展（用户量增长），且扩展时无需重构核心架构。
落地场景：
功能扩展：记账 App 后续新增「预算管理」模块，可直接接入应用层，不影响现有记账、统计模块；
规模扩展：用户量从 1 万涨到 10 万，只需增加应用节点数量，通过 SLB 分发请求。
核心策略：模块化设计、接口标准化、水平扩容优先（优于垂直扩容）。
6. 数据一致性原则
定义：系统在并发操作、故障恢复时，数据始终保持准确、完整，避免出现 “账单录入成功但数据库无记录” 的情况。
落地场景：
记账 App 的账单录入流程：先写数据库 → 再更新缓存 → 最后返回结果，避免缓存与数据库数据不一致；
关键操作（如账单删除）加事务控制，确保要么全部成功，要么全部回滚。
核心策略：数据库事务、缓存更新策略（Cache-Aside）、分布式锁（高并发场景）。
7. 极简设计原则
定义：架构设计 “够用就好”，不引入当前业务用不上的复杂技术，避免过度设计。
落地场景：
记账 App 10000 DAU 无需引入微服务架构、K8s 容器编排，用简单的 “双节点 + 主从数据库” 即可支撑；
不使用 Elasticsearch 做账单搜索（用户量小），直接用 MySQL 的模糊查询满足需求。
价值：降低开发、运维成本，减少故障点。
8. 可观测性原则
定义：系统具备监控、日志、追踪能力，能实时感知运行状态，故障发生时可快速定位根因。
落地场景：
记账 App 监控服务器 CPU / 内存、接口响应时间、数据库连接数；
收集应用日志、访问日志，通过日志分析工具（如 ELK 轻量版）排查问题；
核心接口添加链路追踪，记录一次请求从接入层到数据层的完整路径。
价值：从 “被动救火” 变为 “主动预警”，提升运维效率。
9. 安全性原则
定义：系统能抵御常见的安全威胁，保护用户数据和系统本身的安全。
落地场景：
记账 App 的用户密码采用哈希加密存储（如 bcrypt 算法），不存储明文；
敏感数据（如手机号、身份证号）用 AES 加密后存入数据库；
接口做权限校验，避免越权访问（如用户 A 不能查看用户 B 的账单）。
核心策略：数据加密、权限控制、接口防刷、SQL 注入防护、HTTPS 传输。
10. 演进式架构原则
定义：架构不是 “一步到位” 的，而是随着业务发展逐步迭代升级，避免一次性设计 “完美架构”。
落地场景：
记账 App 初期（100 DAU）用 “单服务器 + 本地数据库”；
增长到 1000 DAU 时，升级为 “单服务器 + 云数据库 + Redis”；
增长到 10000 DAU 时，升级为 “双节点 + 主从数据库 + SLB”；
未来增长到 10 万 DAU 时，再升级为微服务架构。
价值：匹配业务发展节奏，降低初期投入风险。