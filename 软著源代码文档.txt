================================================================================
                        智能AI记账管理系统 V1.0
                           软件著作权源代码文档
================================================================================

                              前30页源代码
                          （第1页 - 第30页）

================================================================================
                              第1页
================================================================================
// 文件: app/lib/main.dart
// 应用程序入口文件

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'theme/app_theme.dart';
import 'pages/main_navigation.dart';
import 'providers/theme_provider.dart';
import 'providers/locale_provider.dart';
import 'l10n/app_localizations.dart';
import 'l10n/generated/app_localizations.dart' as gen;
import 'core/logger.dart';
import 'services/cleanup_scheduler.dart';
import 'services/app_config_service.dart';
import 'services/http_service.dart';
import 'services/app_upgrade_service.dart';
import 'services/auto_sync_service.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize logging system
  await logger.init(
    config: LogConfig(
      maxFileSize: 5 * 1024 * 1024, // 5MB per file
      retentionDays: 7, // Keep logs for 7 days
      maxTotalSize: 50 * 1024 * 1024, // 50MB total max
      persistToFile: true,
      fileLogLevel: kDebugMode ? LogLevel.debug : LogLevel.info,
    ),
  );

  // Set system UI overlay style
  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.light,
    ),
  );

  // Log app startup
  logger.info('Application started', tag: 'App');

  // Initialize app configuration from server
  try {
    await AppConfigService().initialize();
    logger.info('App config service initialized', tag: 'App');
    // Reinitialize HTTP service with new config
    HttpService().reinitialize();
    logger.info('HTTP service reinitialized with server config', tag: 'App');

================================================================================
                              第2页
================================================================================
  } catch (e) {
    logger.warning('Failed to initialize app config: \$e', tag: 'App');
  }

  // Initialize HTTP service (load auth token from secure storage)
  try {
    await HttpService().initialize();
    logger.info('HTTP service initialized with auth token', tag: 'App');
  } catch (e) {
    logger.warning('Failed to initialize HTTP service: \$e', tag: 'App');
  }

  // Initialize cleanup scheduler for source files
  try {
    await CleanupScheduler().initialize();
    logger.info('Cleanup scheduler initialized', tag: 'App');
  } catch (e) {
    logger.warning('Failed to initialize cleanup scheduler: \$e', tag: 'App');
  }

  // Initialize auto-sync service
  try {
    await AutoSyncService().initialize();
    logger.info('Auto-sync service initialized', tag: 'App');
  } catch (e) {
    logger.warning('Failed to initialize auto-sync service: \$e', tag: 'App');
  }

  // Check for app updates (non-blocking)
  AppUpgradeService().checkUpdate().then((result) {
    if (result.hasUpdate) {
      logger.info(
        'App update available: \${result.latestVersion?.versionName ?? "unknown"}, '
        'force=\${result.isForceUpdate}',
        tag: 'App',
      );
    }
  }).catchError((e) {
    logger.warning('Failed to check for updates: \$e', tag: 'App');
  });

  runApp(const ProviderScope(child: MyApp()));
}

/// Root application widget with lifecycle observer
class MyApp extends ConsumerStatefulWidget {
  const MyApp({super.key});

  @override
  ConsumerState<MyApp> createState() => _MyAppState();
}

class _MyAppState extends ConsumerState<MyApp> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();

================================================================================
                              第3页
================================================================================
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    logger.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.resumed) {
      // Trigger log cleanup check when app resumes from background
      logger.onAppResumed();
      logger.debug('App resumed from background', tag: 'App');
    } else if (state == AppLifecycleState.paused) {
      logger.debug('App paused (entering background)', tag: 'App');
    }
  }

  @override
  Widget build(BuildContext context) {
    // 监听主题状态变化，确保主题切换时 UI 会重建
    final themeState = ref.watch(themeProvider);
    final themeNotifier = ref.read(themeProvider.notifier);
    final localeState = ref.watch(localeProvider);
    final l10n = ref.watch(localeProvider.notifier).l10n;

    // 根据是否使用自定义主题选择对应的 ThemeData
    final lightTheme = themeState.isUsingCustomTheme
        ? themeNotifier.getLightTheme()
        : AppTheme.createLightTheme(themeNotifier.primaryColor);
    final darkTheme = themeState.isUsingCustomTheme
        ? themeNotifier.getDarkTheme()
        : AppTheme.createDarkTheme(themeNotifier.primaryColor);

    return MaterialApp(
      title: l10n.appName,
      debugShowCheckedModeBanner: false,
      theme: lightTheme,
      darkTheme: darkTheme,
      themeMode: themeNotifier.themeMode,
      locale: localeState.locale,
      supportedLocales: gen.S.supportedLocales,
      localizationsDelegates: [
        gen.S.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
        AppLocalizationsDelegate(localeState.effectiveLanguage),
      ],
      home: const MainNavigation(),
    );
  }
}

================================================================================
                              第4页
================================================================================
// 文件: app/lib/models/transaction.dart
// 交易数据模型

import 'transaction_split.dart';
import 'transaction_location.dart';

enum TransactionType {
  expense,
  income,
  transfer,
}

/// Source of transaction creation
enum TransactionSource {
  manual,  // 0: Manual input
  image,   // 1: Image recognition (receipt scanning)
  voice,   // 2: Voice recognition
  email,   // 3: Email bill parsing
  import_,  // 4: Batch import from bill files
}

/// External source for imported transactions
enum ExternalSource {
  wechatPay,    // 微信支付
  alipay,       // 支付宝
  cmbBank,      // 招商银行
  icbcBank,     // 工商银行
  abcBank,      // 农业银行
  ccbBank,      // 建设银行
  bocBank,      // 中国银行
  otherBank,    // 其他银行
  generic,      // 通用格式
}

class Transaction {
  final String id;
  final TransactionType type;
  final double amount;
  final String category;
  final String? subcategory;
  final String? note;
  final DateTime date;
  final String accountId;
  final String? toAccountId; // For transfers
  final String? imageUrl;
  final bool isSplit; // 是否为拆分交易
  final List<TransactionSplit>? splits; // 拆分项列表
  final bool isReimbursable; // 是否可报销
  final bool isReimbursed;   // 是否已报销
  final List<String>? tags;  // 标签列表
  final DateTime createdAt;
  final DateTime updatedAt;

================================================================================
                              第5页
================================================================================
  // Source file fields for AI recognition
  final TransactionSource source; // 来源: 手动/图片/语音/邮件/导入
  final double? aiConfidence;     // AI识别置信度 (0-1)
  final String? sourceFileLocalPath;  // 本地源文件路径
  final String? sourceFileServerUrl;  // 服务器源文件URL
  final String? sourceFileType;       // 文件MIME类型
  final int? sourceFileSize;          // 文件大小(bytes)
  final String? recognitionRawData;   // AI识别原始响应JSON
  final DateTime? sourceFileExpiresAt; // 源文件过期时间

  // Batch import fields
  final String? externalId;           // 外部交易号
  final ExternalSource? externalSource; // 外部来源标识
  final String? importBatchId;        // 导入批次ID
  final String? rawMerchant;          // 原始商户名

  // === 2.0新增：小金库关联 ===
  final String? vaultId;              // 关联的小金库ID

  // === 2.0新增：位置信息 ===
  final TransactionLocation? location; // 交易发生位置信息

  // === 2.0新增：钱龄相关 ===
  final int? moneyAge;                // 该笔消费的钱龄（天数）

  Transaction({
    required this.id,
    required this.type,
    required this.amount,
    required this.category,
    this.subcategory,
    this.note,
    required this.date,
    required this.accountId,
    this.toAccountId,
    this.imageUrl,
    this.isSplit = false,
    this.splits,
    this.isReimbursable = false,
    this.isReimbursed = false,
    this.tags,
    DateTime? createdAt,
    DateTime? updatedAt,
    this.source = TransactionSource.manual,
    this.aiConfidence,
    this.sourceFileLocalPath,
    this.sourceFileServerUrl,
    this.sourceFileType,
    this.sourceFileSize,
    this.recognitionRawData,
    this.sourceFileExpiresAt,
    this.externalId,

================================================================================
                              第6页
================================================================================
    this.externalSource,
    this.importBatchId,
    this.rawMerchant,
    this.vaultId,
    this.location,
    this.moneyAge,
  })  : createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now();

  /// 获取拆分项的分类摘要显示
  String get splitCategorySummary {
    if (!isSplit || splits == null || splits!.isEmpty) {
      return category;
    }
    if (splits!.length == 1) {
      return splits!.first.category;
    }
    return '\${splits!.first.category} 等\${splits!.length}项';
  }

  Transaction copyWith({
    String? id,
    TransactionType? type,
    double? amount,
    String? category,
    String? subcategory,
    String? note,
    DateTime? date,
    String? accountId,
    String? toAccountId,
    String? imageUrl,
    bool? isSplit,
    List<TransactionSplit>? splits,
    bool? isReimbursable,
    bool? isReimbursed,
    List<String>? tags,
    TransactionSource? source,
    double? aiConfidence,
    String? sourceFileLocalPath,
    String? sourceFileServerUrl,
    String? sourceFileType,
    int? sourceFileSize,
    String? recognitionRawData,
    DateTime? sourceFileExpiresAt,
    String? externalId,
    ExternalSource? externalSource,
    String? importBatchId,
    String? rawMerchant,
    String? vaultId,
    TransactionLocation? location,
    int? moneyAge,
  }) {

================================================================================
                              第7页
================================================================================
    return Transaction(
      id: id ?? this.id,
      type: type ?? this.type,
      amount: amount ?? this.amount,
      category: category ?? this.category,
      subcategory: subcategory ?? this.subcategory,
      note: note ?? this.note,
      date: date ?? this.date,
      accountId: accountId ?? this.accountId,
      toAccountId: toAccountId ?? this.toAccountId,
      imageUrl: imageUrl ?? this.imageUrl,
      isSplit: isSplit ?? this.isSplit,
      splits: splits ?? this.splits,
      isReimbursable: isReimbursable ?? this.isReimbursable,
      isReimbursed: isReimbursed ?? this.isReimbursed,
      tags: tags ?? this.tags,
      createdAt: createdAt,
      updatedAt: DateTime.now(),
      source: source ?? this.source,
      aiConfidence: aiConfidence ?? this.aiConfidence,
      sourceFileLocalPath: sourceFileLocalPath ?? this.sourceFileLocalPath,
      sourceFileServerUrl: sourceFileServerUrl ?? this.sourceFileServerUrl,
      sourceFileType: sourceFileType ?? this.sourceFileType,
      sourceFileSize: sourceFileSize ?? this.sourceFileSize,
      recognitionRawData: recognitionRawData ?? this.recognitionRawData,
      sourceFileExpiresAt: sourceFileExpiresAt ?? this.sourceFileExpiresAt,
      externalId: externalId ?? this.externalId,
      externalSource: externalSource ?? this.externalSource,
      importBatchId: importBatchId ?? this.importBatchId,
      rawMerchant: rawMerchant ?? this.rawMerchant,
      vaultId: vaultId ?? this.vaultId,
      location: location ?? this.location,
      moneyAge: moneyAge ?? this.moneyAge,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'type': type.index,
      'amount': amount,
      'category': category,
      'subcategory': subcategory,
      'note': note,
      'date': date.toIso8601String(),
      'accountId': accountId,
      'toAccountId': toAccountId,
      'imageUrl': imageUrl,
      'isSplit': isSplit ? 1 : 0,
      'isReimbursable': isReimbursable ? 1 : 0,
      'isReimbursed': isReimbursed ? 1 : 0,

================================================================================
                              第8页
================================================================================
      'tags': tags?.join(','),
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
      'source': source.index,
      'aiConfidence': aiConfidence,
      'sourceFileLocalPath': sourceFileLocalPath,
      'sourceFileServerUrl': sourceFileServerUrl,
      'sourceFileType': sourceFileType,
      'sourceFileSize': sourceFileSize,
      'recognitionRawData': recognitionRawData,
      'sourceFileExpiresAt': sourceFileExpiresAt?.toIso8601String(),
      'externalId': externalId,
      'externalSource': externalSource?.index,
      'importBatchId': importBatchId,
      'rawMerchant': rawMerchant,
      'vaultId': vaultId,
      'latitude': location?.latitude,
      'longitude': location?.longitude,
      'placeName': location?.placeName,
      'address': location?.address,
      'locationType': location?.locationType?.index,
      'moneyAge': moneyAge,
    };
  }

  factory Transaction.fromMap(Map<String, dynamic> map, 
      {List<TransactionSplit>? splits}) {
    return Transaction(
      id: map['id'],
      type: TransactionType.values[map['type']],
      amount: (map['amount'] as num).toDouble(),
      category: map['category'],
      subcategory: map['subcategory'],
      note: map['note'],
      date: DateTime.parse(map['date']),
      accountId: map['accountId'],
      toAccountId: map['toAccountId'],
      imageUrl: map['imageUrl'],
      isSplit: map['isSplit'] == 1,
      splits: splits,
      isReimbursable: map['isReimbursable'] == 1,
      isReimbursed: map['isReimbursed'] == 1,
      tags: map['tags'] != null && (map['tags'] as String).isNotEmpty
          ? (map['tags'] as String).split(',')
          : null,
      createdAt: DateTime.parse(map['createdAt']),
      updatedAt: DateTime.parse(map['updatedAt']),
      source: map['source'] != null
          ? TransactionSource.values[map['source'] as int]
          : TransactionSource.manual,

================================================================================
                              第9页
================================================================================
      aiConfidence: map['aiConfidence'] != null
          ? (map['aiConfidence'] as num).toDouble()
          : null,
      sourceFileLocalPath: map['sourceFileLocalPath'],
      sourceFileServerUrl: map['sourceFileServerUrl'],
      sourceFileType: map['sourceFileType'],
      sourceFileSize: map['sourceFileSize'] as int?,
      recognitionRawData: map['recognitionRawData'],
      sourceFileExpiresAt: map['sourceFileExpiresAt'] != null
          ? DateTime.parse(map['sourceFileExpiresAt'])
          : null,
      externalId: map['externalId'],
      externalSource: map['externalSource'] != null
          ? ExternalSource.values[map['externalSource'] as int]
          : null,
      importBatchId: map['importBatchId'],
      rawMerchant: map['rawMerchant'],
      vaultId: map['vaultId'],
      location: map['latitude'] != null && map['longitude'] != null
          ? TransactionLocation(
              latitude: (map['latitude'] as num).toDouble(),
              longitude: (map['longitude'] as num).toDouble(),
              placeName: map['placeName'],
              address: map['address'],
              locationType: map['locationType'] != null
                  ? LocationType.values[map['locationType'] as int]
                  : null,
            )
          : null,
      moneyAge: map['moneyAge'] as int?,
    );
  }

  /// Check if source file is available
  bool get hasSourceFile {
    return sourceFileLocalPath != null || sourceFileServerUrl != null;
  }

  /// Check if source file has expired
  bool get isSourceFileExpired {
    if (sourceFileExpiresAt == null) return false;
    return DateTime.now().isAfter(sourceFileExpiresAt!);
  }

  /// Get the source file path
  String? get sourceFilePath {
    return sourceFileLocalPath ?? sourceFileServerUrl;
  }

  /// Check if source is from image recognition
  bool get isFromImage => source == TransactionSource.image;

================================================================================
                              第10页
================================================================================
  /// Check if source is from voice recognition
  bool get isFromVoice => source == TransactionSource.voice;

  /// Check if source is from batch import
  bool get isFromImport => source == TransactionSource.import_;

  /// Get external source display name
  String? get externalSourceName {
    if (externalSource == null) return null;
    switch (externalSource!) {
      case ExternalSource.wechatPay:
        return '微信支付';
      case ExternalSource.alipay:
        return '支付宝';
      case ExternalSource.cmbBank:
        return '招商银行';
      case ExternalSource.icbcBank:
        return '工商银行';
      case ExternalSource.abcBank:
        return '农业银行';
      case ExternalSource.ccbBank:
        return '建设银行';
      case ExternalSource.bocBank:
        return '中国银行';
      case ExternalSource.otherBank:
        return '其他银行';
      case ExternalSource.generic:
        return '通用导入';
    }
  }

  // === 2.0新增辅助方法 ===

  /// 是否关联了小金库
  bool get hasVault => vaultId != null;

  /// 是否有位置信息
  bool get hasLocation => location != null;

  /// 是否有钱龄信息
  bool get hasMoneyAge => moneyAge != null;

  /// 是否为支出类型
  bool get isExpense => type == TransactionType.expense;

  /// 是否为收入类型
  bool get isIncome => type == TransactionType.income;

  /// 是否为转账类型
  bool get isTransfer => type == TransactionType.transfer;
}


================================================================================
                              第11页
================================================================================
// 文件: app/lib/models/budget_vault.dart
// 小金库（零基预算）数据模型

import 'package:flutter/material.dart';

/// 小金库类型
enum VaultType {
  /// 固定支出 - 每月必须支付（房租、水电、保险）
  fixed,

  /// 弹性支出 - 可调整（餐饮、娱乐、购物）
  flexible,

  /// 储蓄目标 - 长期积累（旅行基金、应急金、购房）
  savings,

  /// 债务还款 - 信用卡、贷款
  debt,
}

extension VaultTypeExtension on VaultType {
  String get displayName {
    switch (this) {
      case VaultType.fixed:
        return '固定支出';
      case VaultType.flexible:
        return '弹性支出';
      case VaultType.savings:
        return '储蓄目标';
      case VaultType.debt:
        return '债务还款';
    }
  }

  String get description {
    switch (this) {
      case VaultType.fixed:
        return '每月必须支付的固定开支';
      case VaultType.flexible:
        return '可根据情况调整的弹性消费';
      case VaultType.savings:
        return '长期积累的储蓄目标';
      case VaultType.debt:
        return '信用卡和贷款还款';
    }
  }

  IconData get defaultIcon {
    switch (this) {
      case VaultType.fixed:
        return Icons.home;

================================================================================
                              第12页
================================================================================
      case VaultType.flexible:
        return Icons.shopping_bag;
      case VaultType.savings:
        return Icons.savings;
      case VaultType.debt:
        return Icons.credit_card;
    }
  }

  Color get defaultColor {
    switch (this) {
      case VaultType.fixed:
        return Colors.blue;
      case VaultType.flexible:
        return Colors.orange;
      case VaultType.savings:
        return Colors.green;
      case VaultType.debt:
        return Colors.red;
    }
  }

  /// 分配优先级（数字越小优先级越高）
  int get allocationPriority {
    switch (this) {
      case VaultType.fixed:
        return 1;  // 固定支出优先
      case VaultType.debt:
        return 2;  // 债务其次
      case VaultType.savings:
        return 3;  // 储蓄第三
      case VaultType.flexible:
        return 4;  // 弹性最后
    }
  }
}

/// 分配类型枚举
enum AllocationType {
  /// 固定金额分配
  fixed,

  /// 按百分比分配
  percentage,

  /// 分配剩余金额
  remainder,

  /// 补齐到目标金额
  topUp,
}

================================================================================
                              第13页
================================================================================
extension AllocationTypeExtension on AllocationType {
  String get displayName {
    switch (this) {
      case AllocationType.fixed:
        return '固定金额';
      case AllocationType.percentage:
        return '按百分比';
      case AllocationType.remainder:
        return '分配剩余';
      case AllocationType.topUp:
        return '补齐目标';
    }
  }

  String get description {
    switch (this) {
      case AllocationType.fixed:
        return '每次分配固定金额到此小金库';
      case AllocationType.percentage:
        return '按收入的百分比分配';
      case AllocationType.remainder:
        return '其他小金库分配后的剩余金额';
      case AllocationType.topUp:
        return '补充到目标金额';
    }
  }
}

/// 小金库状态
enum VaultStatus {
  /// 健康 - 资金充足
  healthy,

  /// 资金不足 - 未达到目标
  underfunded,

  /// 即将用完 - 使用率超过90%
  almostEmpty,

  /// 已超支
  overSpent,
}

extension VaultStatusExtension on VaultStatus {
  String get displayName {
    switch (this) {
      case VaultStatus.healthy:
        return '健康';
      case VaultStatus.underfunded:
        return '资金不足';

================================================================================
                              第14页
================================================================================
      case VaultStatus.almostEmpty:
        return '即将用完';
      case VaultStatus.overSpent:
        return '已超支';
    }
  }

  Color get color {
    switch (this) {
      case VaultStatus.healthy:
        return Colors.green;
      case VaultStatus.underfunded:
        return Colors.orange;
      case VaultStatus.almostEmpty:
        return Colors.amber;
      case VaultStatus.overSpent:
        return Colors.red;
    }
  }

  IconData get icon {
    switch (this) {
      case VaultStatus.healthy:
        return Icons.check_circle;
      case VaultStatus.underfunded:
        return Icons.warning;
      case VaultStatus.almostEmpty:
        return Icons.error_outline;
      case VaultStatus.overSpent:
        return Icons.dangerous;
    }
  }
}

/// 周期频率
enum RecurrenceFrequency {
  daily,
  weekly,
  biweekly,
  monthly,
  yearly,
}

extension RecurrenceFrequencyExtension on RecurrenceFrequency {
  String get displayName {
    switch (this) {
      case RecurrenceFrequency.daily:
        return '每天';
      case RecurrenceFrequency.weekly:
        return '每周';
      case RecurrenceFrequency.biweekly:

================================================================================
                              第15页
================================================================================
        return '每两周';
      case RecurrenceFrequency.monthly:
        return '每月';
      case RecurrenceFrequency.yearly:
        return '每年';
    }
  }
}

/// 周期规则
class RecurrenceRule {
  final RecurrenceFrequency frequency;
  final int interval;           // 间隔（如每2周的2）
  final int? dayOfWeek;         // 周几（1-7，用于weekly）
  final int? dayOfMonth;        // 几号（1-31，用于monthly）
  final int? monthOfYear;       // 几月（1-12，用于yearly）
  final DateTime? startDate;    // 开始日期
  final DateTime? endDate;      // 结束日期

  const RecurrenceRule({
    required this.frequency,
    this.interval = 1,
    this.dayOfWeek,
    this.dayOfMonth,
    this.monthOfYear,
    this.startDate,
    this.endDate,
  });

  Map<String, dynamic> toMap() {
    return {
      'frequency': frequency.index,
      'interval': interval,
      'dayOfWeek': dayOfWeek,
      'dayOfMonth': dayOfMonth,
      'monthOfYear': monthOfYear,
      'startDate': startDate?.millisecondsSinceEpoch,
      'endDate': endDate?.millisecondsSinceEpoch,
    };
  }

  factory RecurrenceRule.fromMap(Map<String, dynamic> map) {
    return RecurrenceRule(
      frequency: RecurrenceFrequency.values[map['frequency'] as int],
      interval: map['interval'] as int? ?? 1,
      dayOfWeek: map['dayOfWeek'] as int?,
      dayOfMonth: map['dayOfMonth'] as int?,
      monthOfYear: map['monthOfYear'] as int?,
      startDate: map['startDate'] != null
          ? DateTime.fromMillisecondsSinceEpoch(map['startDate'] as int)
          : null,

================================================================================
                              第16页
================================================================================
      endDate: map['endDate'] != null
          ? DateTime.fromMillisecondsSinceEpoch(map['endDate'] as int)
          : null,
    );
  }

  /// 获取下一个执行日期
  DateTime? getNextOccurrence(DateTime from) {
    switch (frequency) {
      case RecurrenceFrequency.daily:
        return from.add(Duration(days: interval));
      case RecurrenceFrequency.weekly:
        return from.add(Duration(days: 7 * interval));
      case RecurrenceFrequency.biweekly:
        return from.add(Duration(days: 14 * interval));
      case RecurrenceFrequency.monthly:
        return DateTime(from.year, from.month + interval, 
            dayOfMonth ?? from.day);
      case RecurrenceFrequency.yearly:
        return DateTime(from.year + interval, monthOfYear ?? from.month, 
            dayOfMonth ?? from.day);
    }
  }
}

/// 小金库模型
///
/// 小金库是零基预算的核心概念，每个小金库代表一个预算类别或储蓄目标。
/// 收入进来后分配到各个小金库，支出时从对应的小金库扣减。
class BudgetVault {
  final String id;
  final String name;
  final String? description;
  final IconData icon;
  final Color color;
  final VaultType type;
  final double targetAmount;        // 目标金额
  final double allocatedAmount;     // 已分配金额
  final double spentAmount;         // 已花费金额
  final DateTime? dueDate;          // 到期日
  final bool isRecurring;           // 是否周期性
  final RecurrenceRule? recurrence; // 周期规则
  final String? linkedCategoryId;   // 关联的消费分类ID
  final List<String>? linkedCategoryIds; // 关联的多个分类ID
  final String ledgerId;            // 所属账本ID
  final bool isEnabled;             // 是否启用
  final int sortOrder;              // 排序顺序
  final DateTime createdAt;
  final DateTime updatedAt;

================================================================================
                              第17页
================================================================================
  // 分配策略相关属性
  final AllocationType allocationType;  // 分配类型
  final double? targetAllocation;       // 固定分配金额
  final double? targetPercentage;       // 分配百分比（0-1）

  BudgetVault({
    required this.id,
    required this.name,
    this.description,
    required this.icon,
    required this.color,
    required this.type,
    required this.targetAmount,
    this.allocatedAmount = 0,
    this.spentAmount = 0,
    this.dueDate,
    this.isRecurring = false,
    this.recurrence,
    this.linkedCategoryId,
    this.linkedCategoryIds,
    required this.ledgerId,
    this.isEnabled = true,
    this.sortOrder = 0,
    DateTime? createdAt,
    DateTime? updatedAt,
    this.allocationType = AllocationType.fixed,
    this.targetAllocation,
    this.targetPercentage,
  })  : createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now();

  /// 当前金额（已分配 - 已花费）
  double get currentAmount => allocatedAmount - spentAmount;

  /// 剩余可用金额（别名）
  double get available => currentAmount;

  /// 完成度（用于储蓄目标）
  double get progress =>
      targetAmount > 0 ? (allocatedAmount / targetAmount).clamp(0.0, 1.0) : 0;

  /// 使用率（用于预算控制）
  double get usageRate =>
      allocatedAmount > 0 
          ? (spentAmount / allocatedAmount).clamp(0.0, double.infinity) 
          : 0;

  /// 剩余预算比例
  double get remainingRate => 1.0 - usageRate.clamp(0.0, 1.0);

================================================================================
                              第18页
================================================================================
  /// 状态
  VaultStatus get status {
    if (available < 0) return VaultStatus.overSpent;
    if (usageRate > 0.9) return VaultStatus.almostEmpty;
    if (progress < 1.0 && type == VaultType.savings) 
        return VaultStatus.underfunded;
    if (allocatedAmount < targetAmount && type == VaultType.fixed) 
        return VaultStatus.underfunded;
    return VaultStatus.healthy;
  }

  /// 是否超支
  bool get isOverSpent => available < 0;

  /// 是否接近用完（使用率>80%）
  bool get isAlmostEmpty => usageRate > 0.8 && !isOverSpent;

  /// 距离到期日的天数
  int? get daysUntilDue {
    if (dueDate == null) return null;
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final due = DateTime(dueDate!.year, dueDate!.month, dueDate!.day);
    return due.difference(today).inDays;
  }

  /// 是否即将到期（3天内）
  bool get isDueSoon => 
      daysUntilDue != null && daysUntilDue! <= 3 && daysUntilDue! >= 0;

  /// 是否已过期
  bool get isOverdue => daysUntilDue != null && daysUntilDue! < 0;

  /// 超支金额（如果超支）
  double get overspentAmount => isOverSpent ? -available : 0;

  BudgetVault copyWith({
    String? id,
    String? name,
    String? description,
    IconData? icon,
    Color? color,
    VaultType? type,
    double? targetAmount,
    double? allocatedAmount,
    double? spentAmount,
    DateTime? dueDate,
    bool? isRecurring,
    RecurrenceRule? recurrence,
    String? linkedCategoryId,
    List<String>? linkedCategoryIds,

================================================================================
                              第19页
================================================================================
    String? ledgerId,
    bool? isEnabled,
    int? sortOrder,
    DateTime? createdAt,
    DateTime? updatedAt,
    AllocationType? allocationType,
    double? targetAllocation,
    double? targetPercentage,
  }) {
    return BudgetVault(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      icon: icon ?? this.icon,
      color: color ?? this.color,
      type: type ?? this.type,
      targetAmount: targetAmount ?? this.targetAmount,
      allocatedAmount: allocatedAmount ?? this.allocatedAmount,
      spentAmount: spentAmount ?? this.spentAmount,
      dueDate: dueDate ?? this.dueDate,
      isRecurring: isRecurring ?? this.isRecurring,
      recurrence: recurrence ?? this.recurrence,
      linkedCategoryId: linkedCategoryId ?? this.linkedCategoryId,
      linkedCategoryIds: linkedCategoryIds ?? this.linkedCategoryIds,
      ledgerId: ledgerId ?? this.ledgerId,
      isEnabled: isEnabled ?? this.isEnabled,
      sortOrder: sortOrder ?? this.sortOrder,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? DateTime.now(),
      allocationType: allocationType ?? this.allocationType,
      targetAllocation: targetAllocation ?? this.targetAllocation,
      targetPercentage: targetPercentage ?? this.targetPercentage,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'iconCode': icon.codePoint,
      'colorValue': color.toARGB32(),
      'type': type.index,
      'targetAmount': targetAmount,
      'allocatedAmount': allocatedAmount,
      'spentAmount': spentAmount,
      'dueDate': dueDate?.millisecondsSinceEpoch,
      'isRecurring': isRecurring ? 1 : 0,
      'recurrenceJson': recurrence?.toMap().toString(),
      'linkedCategoryId': linkedCategoryId,
      'linkedCategoryIds': linkedCategoryIds?.join(','),

================================================================================
                              第20页
================================================================================
      'ledgerId': ledgerId,
      'isEnabled': isEnabled ? 1 : 0,
      'sortOrder': sortOrder,
      'createdAt': createdAt.millisecondsSinceEpoch,
      'updatedAt': updatedAt.millisecondsSinceEpoch,
      'allocationType': allocationType.index,
      'targetAllocation': targetAllocation,
      'targetPercentage': targetPercentage,
    };
  }

  factory BudgetVault.fromMap(Map<String, dynamic> map) {
    return BudgetVault(
      id: map['id'] as String,
      name: map['name'] as String,
      description: map['description'] as String?,
      icon: IconData(map['iconCode'] as int, fontFamily: 'MaterialIcons'),
      color: Color(map['colorValue'] as int),
      type: VaultType.values[map['type'] as int],
      targetAmount: (map['targetAmount'] as num).toDouble(),
      allocatedAmount: (map['allocatedAmount'] as num?)?.toDouble() ?? 0,
      spentAmount: (map['spentAmount'] as num?)?.toDouble() ?? 0,
      dueDate: map['dueDate'] != null
          ? DateTime.fromMillisecondsSinceEpoch(map['dueDate'] as int)
          : null,
      isRecurring: map['isRecurring'] == 1,
      recurrence: null,
      linkedCategoryId: map['linkedCategoryId'] as String?,
      linkedCategoryIds: map['linkedCategoryIds'] != null
          ? (map['linkedCategoryIds'] as String).split(',')
          : null,
      ledgerId: map['ledgerId'] as String,
      isEnabled: map['isEnabled'] != 0,
      sortOrder: map['sortOrder'] as int? ?? 0,
      createdAt: DateTime.fromMillisecondsSinceEpoch(map['createdAt'] as int),
      updatedAt: map['updatedAt'] != null
          ? DateTime.fromMillisecondsSinceEpoch(map['updatedAt'] as int)
          : null,
      allocationType: 
          AllocationType.values[map['allocationType'] as int? ?? 0],
      targetAllocation: (map['targetAllocation'] as num?)?.toDouble(),
      targetPercentage: (map['targetPercentage'] as num?)?.toDouble(),
    );
  }
}

/// 小金库分配记录
///
/// 记录每次收入分配到小金库的详情
class VaultAllocation {
  final String id;


================================================================================
                              第21页
================================================================================
  final String vaultId;
  final String? incomeTransactionId;  // 关联的收入交易
  final double amount;
  final String? note;
  final DateTime allocatedAt;

  const VaultAllocation({
    required this.id,
    required this.vaultId,
    this.incomeTransactionId,
    required this.amount,
    this.note,
    required this.allocatedAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'vaultId': vaultId,
      'incomeTransactionId': incomeTransactionId,
      'amount': amount,
      'note': note,
      'allocatedAt': allocatedAt.millisecondsSinceEpoch,
    };
  }

  factory VaultAllocation.fromMap(Map<String, dynamic> map) {
    return VaultAllocation(
      id: map['id'] as String,
      vaultId: map['vaultId'] as String,
      incomeTransactionId: map['incomeTransactionId'] as String?,
      amount: (map['amount'] as num).toDouble(),
      note: map['note'] as String?,
      allocatedAt: 
          DateTime.fromMillisecondsSinceEpoch(map['allocatedAt'] as int),
    );
  }
}

/// 小金库调拨记录
///
/// 记录小金库之间的资金转移
class VaultTransfer {
  final String id;
  final String fromVaultId;
  final String toVaultId;
  final double amount;
  final String? note;
  final DateTime transferredAt;

  const VaultTransfer({
    required this.id,

================================================================================
                              第22页
================================================================================
    required this.fromVaultId,
    required this.toVaultId,
    required this.amount,
    this.note,
    required this.transferredAt,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'fromVaultId': fromVaultId,
      'toVaultId': toVaultId,
      'amount': amount,
      'note': note,
      'transferredAt': transferredAt.millisecondsSinceEpoch,
    };
  }

  factory VaultTransfer.fromMap(Map<String, dynamic> map) {
    return VaultTransfer(
      id: map['id'] as String,
      fromVaultId: map['fromVaultId'] as String,
      toVaultId: map['toVaultId'] as String,
      amount: (map['amount'] as num).toDouble(),
      note: map['note'] as String?,
      transferredAt: 
          DateTime.fromMillisecondsSinceEpoch(map['transferredAt'] as int),
    );
  }
}

/// 小金库统计摘要
class VaultSummary {
  final int totalVaults;
  final double totalAllocated;
  final double totalSpent;
  final double totalAvailable;
  final int healthyCount;
  final int underfundedCount;
  final int almostEmptyCount;
  final int overSpentCount;
  final Map<VaultType, double> allocationByType;
  final Map<VaultType, double> spentByType;

  const VaultSummary({
    required this.totalVaults,
    required this.totalAllocated,
    required this.totalSpent,
    required this.totalAvailable,
    required this.healthyCount,
    required this.underfundedCount,

================================================================================
                              第23页
================================================================================
    required this.almostEmptyCount,
    required this.overSpentCount,
    required this.allocationByType,
    required this.spentByType,
  });

  /// 总体使用率
  double get overallUsageRate =>
      totalAllocated > 0 ? totalSpent / totalAllocated : 0;

  /// 健康小金库比例
  double get healthyRate =>
      totalVaults > 0 ? healthyCount / totalVaults : 0;

  factory VaultSummary.empty() {
    return const VaultSummary(
      totalVaults: 0,
      totalAllocated: 0,
      totalSpent: 0,
      totalAvailable: 0,
      healthyCount: 0,
      underfundedCount: 0,
      almostEmptyCount: 0,
      overSpentCount: 0,
      allocationByType: {},
      spentByType: {},
    );
  }
}

// 文件: app/lib/services/ai_service.dart
// AI智能识别服务

import 'dart:io';
import 'dart:typed_data';
import 'qwen_service.dart';
import '../models/category.dart';

/// AI识别结果模型
class AIRecognitionResult {
  final double? amount;
  final String? merchant;
  final String? category;
  final String? date;
  final String? description;
  final String? type; // expense/income
  final List<ReceiptItem>? items; // 小票商品列表
  final String? recognizedText; // 语音识别的原始文本
  final double confidence;
  final bool success;
  final String? errorMessage;

================================================================================
                              第24页
================================================================================
  AIRecognitionResult({
    this.amount,
    this.merchant,
    this.category,
    this.date,
    this.description,
    this.type,
    this.items,
    this.recognizedText,
    this.confidence = 0.0,
    this.success = true,
    this.errorMessage,
  });

  factory AIRecognitionResult.fromQwenResult(QwenRecognitionResult qwenResult) {
    return AIRecognitionResult(
      amount: qwenResult.amount,
      merchant: qwenResult.merchant,
      category: _mapCategory(qwenResult.category, qwenResult.type),
      date: qwenResult.date,
      description: qwenResult.description,
      type: qwenResult.type,
      items: qwenResult.items,
      recognizedText: qwenResult.description,
      confidence: qwenResult.confidence,
      success: qwenResult.success,
      errorMessage: qwenResult.errorMessage,
    );
  }

  factory AIRecognitionResult.fromJson(Map<String, dynamic> json) {
    return AIRecognitionResult(
      amount: json['amount']?.toDouble(),
      merchant: json['merchant'],
      category: json['category'],
      date: json['date'],
      description: json['description'],
      type: json['type'],
      confidence: (json['confidence'] ?? 0.0).toDouble(),
      success: json['success'] ?? true,
      errorMessage: json['error_message'],
    );
  }

  factory AIRecognitionResult.error(String message) {
    return AIRecognitionResult(
      success: false,
      errorMessage: message,
      confidence: 0.0,
    );
  }

================================================================================
                              第25页
================================================================================
  /// 分类映射 - 支持多种中文表达方式
  static String _mapCategory(String? category, String? type) {
    if (category == null || category.isEmpty) {
      return _getOtherCategory(type);
    }

    final lowerCategory = category.toLowerCase().trim();
    if (categoryMap.containsKey(category)) {
      return categoryMap[category]!;
    }

    if (lowerCategory == 'other') {
      return _getOtherCategory(type);
    }
    if (validCategoryIds.contains(lowerCategory)) {
      return lowerCategory;
    }

    // 模糊匹配 - 检查是否包含关键词
    for (final entry in categoryKeywords.entries) {
      for (final keyword in entry.value) {
        if (category.contains(keyword)) {
          return entry.key;
        }
      }
    }

    return _getOtherCategory(type);
  }

  /// 根据类型返回正确的 "其他" 分类
  static String _getOtherCategory(String? type) {
    if (type == 'income') {
      return 'other_income';
    }
    return 'other_expense';
  }

  /// 有效的分类ID列表
  static Set<String> get validCategoryIds => DefaultCategories.allCategoryIds;

  /// 分类映射表 - 精确匹配
  static const Map<String, String> categoryMap = {
    // 支出分类
    '餐饮': 'food',
    '食品': 'food',
    '饮食': 'food',
    '吃饭': 'food',
    '美食': 'food',
    '交通': 'transport',
    '出行': 'transport',

================================================================================
                              第26页
================================================================================
    '打车': 'transport',
    '购物': 'shopping',
    '网购': 'shopping',
    '娱乐': 'entertainment',
    '休闲': 'entertainment',
    '住房': 'housing',
    '房租': 'housing',
    '居住': 'housing',
    '医疗': 'medical',
    '健康': 'medical',
    '看病': 'medical',
    '教育': 'education',
    '学习': 'education',
    '培训': 'education',
    '其他': 'other_expense',
    // 收入分类
    '工资': 'salary',
    '薪水': 'salary',
    '薪资': 'salary',
    '奖金': 'bonus',
    '年终奖': 'bonus',
    '兼职': 'parttime',
    '副业': 'parttime',
    '理财': 'investment',
    '投资': 'investment',
    '收益': 'investment',
  };

  /// 分类关键词映射 - 用于模糊匹配
  static const Map<String, List<String>> categoryKeywords = {
    // 餐饮 - 包含各类餐饮商户
    'food': [
      '餐', '饭', '食', '吃', '喝', '咖啡', '奶茶', '外卖', 
      '早餐', '午餐', '晚餐', '夜宵', '零食', '水果',
      '星巴克', '瑞幸', '喜茶', '奈雪', '蜜雪冰城', '茶百道',
      '麦当劳', '肯德基', '必胜客', '汉堡王', '德克士',
      '海底捞', '西贝', '外婆家', '绿茶', '太二', '九毛九',
      '美团外卖', '饿了么', '盒马', '永辉', '沃尔玛',
      '便利店', '全家', '711', '罗森', '便利蜂',
      '面包', '蛋糕', '烘焙', '甜品', '火锅', '烧烤', '快餐',
    ],
    // 交通 - 包含各类出行服务
    'transport': [
      '车', '交通', '打车', '出租', '地铁', '公交', '滴滴', 
      '加油', '停车', '高铁', '火车', '飞机', '机票',
      '滴滴出行', '高德打车', 'T3出行', '曹操出行',

================================================================================
                              第27页
================================================================================
      '哈啰', '美团单车', '青桔', '共享单车',
      '中国石化', '中国石油', '壳牌', '加油站',
      '12306', '铁路', '携程', '去哪儿', '飞猪', '航空',
      '过路费', '高速', 'ETC', '路费', '车费',
    ],
    // 购物 - 包含各类电商和零售
    'shopping': [
      '购', '买', '超市', '商场', '淘宝', '京东', '网购', 
      '衣服', '鞋',
      '天猫', '拼多多', '唯品会', '苏宁', '国美', '当当',
      '优衣库', 'ZARA', 'HM', 'GAP', '无印良品', 'MUJI',
      '苹果', 'Apple', '小米', '华为', 'OPPO', 'vivo',
      '化妆品', '护肤', '口红', '香水', '丝芙兰', '屈臣氏',
      '日用品', '生活用品', '家居', '百货',
    ],
    // 娱乐 - 包含各类休闲娱乐
    'entertainment': [
      '娱乐', '电影', '游戏', 'KTV', '唱歌', '旅游', 
      '景点', '门票',
      '猫眼', '淘票票', '万达影城', 'CGV', '金逸',
      '腾讯游戏', '网易游戏', '王者荣耀', '和平精英', '原神',
      '爱奇艺', '腾讯视频', '优酷', 'B站', '芒果TV', 
      'Netflix', '会员', 'VIP',
      'Keep', '健身', '瑜伽', '游泳', '运动',
      '演唱会', '演出', '话剧', '音乐会', '展览',
      '迪士尼', '环球影城', '欢乐谷', '方特',
    ],
    // 收入分类
    'salary': ['工资', '薪', '月薪', '底薪', '基本工资'],
    'bonus': ['奖金', '奖', '年终', '提成', '绩效', '分红'],
    'parttime': ['兼职', '副业', '外快', '私单', '接单'],
    'investment': ['理财', '投资', '收益', '利息', '分红', 
        '股票', '基金', '债券', '余额宝', '零钱通'],
  };

  @override
  String toString() {
    return 'AIRecognitionResult(amount: \$amount, merchant: \$merchant, '
        'category: \$category, type: \$type, confidence: \$confidence)';
  }
}

================================================================================
                              第28页
================================================================================
/// 多笔AI识别结果
class MultiAIRecognitionResult {
  final List<AIRecognitionResult> transactions;
  final bool success;
  final String? errorMessage;

  MultiAIRecognitionResult({
    required this.transactions,
    this.success = true,
    this.errorMessage,
  });

  /// 是否包含多笔交易
  bool get isMultiple => transactions.length > 1;

  /// 交易数量
  int get count => transactions.length;

  /// 总金额
  double get totalAmount => transactions.fold(
        0.0,
        (sum, tx) => sum + (tx.amount ?? 0),
      );

  /// 第一笔交易（兼容单笔场景）
  AIRecognitionResult? get first => 
      transactions.isNotEmpty ? transactions.first : null;

  factory MultiAIRecognitionResult.error(String message) {
    return MultiAIRecognitionResult(
      transactions: [],
      success: false,
      errorMessage: message,
    );
  }

  factory MultiAIRecognitionResult.single(AIRecognitionResult result) {
    return MultiAIRecognitionResult(
      transactions: [result],
      success: result.success,
      errorMessage: result.errorMessage,
    );
  }

  factory MultiAIRecognitionResult.fromQwenResult(
      MultiRecognitionResult qwenResult) {
    if (!qwenResult.success) {
      return MultiAIRecognitionResult.error(
          qwenResult.errorMessage ?? '识别失败');
    }

    final aiResults = qwenResult.transactions.map((tx) {

================================================================================
                              第29页
================================================================================
      return AIRecognitionResult.fromQwenResult(tx);
    }).toList();

    return MultiAIRecognitionResult(
      transactions: aiResults,
      success: true,
    );
  }
}

/// AI服务类
/// 使用阿里云通义千问模型进行智能记账
class AIService {
  static final AIService _instance = AIService._internal();
  final QwenService _qwenService = QwenService();

  factory AIService() => _instance;

  AIService._internal();

  /// 图片识别记账
  /// 上传小票/收据图片，使用千问视觉模型自动识别交易信息
  Future<AIRecognitionResult> recognizeImage(File imageFile) async {
    try {
      final qwenResult = await _qwenService.recognizeReceipt(imageFile);
      return AIRecognitionResult.fromQwenResult(qwenResult);
    } catch (e) {
      return AIRecognitionResult.error('图片识别失败: \$e');
    }
  }

  /// 语音识别记账（文本方式）
  /// 解析语音转文本结果，使用千问模型提取交易信息
  Future<AIRecognitionResult> recognizeVoice(String transcribedText) async {
    return parseText(transcribedText);
  }

  /// 音频直接识别记账
  /// 直接从音频数据中识别记账信息，使用千问音频模型
  Future<AIRecognitionResult> recognizeAudio(Uint8List audioData, 
      {String format = 'wav'}) async {
    try {
      final qwenResult = await _qwenService.recognizeAudio(audioData, 
          format: format);
      return AIRecognitionResult.fromQwenResult(qwenResult);
    } catch (e) {
      return AIRecognitionResult.error('音频识别失败: \$e');
    }
  }

================================================================================
                              第30页
================================================================================
  /// 从音频文件识别记账
  Future<AIRecognitionResult> recognizeAudioFile(File audioFile) async {
    try {
      final qwenResult = await _qwenService.recognizeAudioFile(audioFile);
      return AIRecognitionResult.fromQwenResult(qwenResult);
    } catch (e) {
      return AIRecognitionResult.error('音频文件识别失败: \$e');
    }
  }

  /// 音频识别记账 - 支持多笔交易
  /// 一次语音输入可以识别多笔消费/收入
  Future<MultiAIRecognitionResult> recognizeAudioMulti(Uint8List audioData, 
      {String format = 'wav'}) async {
    try {
      final qwenResult = await _qwenService.recognizeAudioMulti(audioData, 
          format: format);
      return MultiAIRecognitionResult.fromQwenResult(qwenResult);
    } catch (e) {
      return MultiAIRecognitionResult.error('音频识别失败: \$e');
    }
  }

  /// 文本解析记账
  /// 从自然语言描述中提取交易信息，使用千问模型
  Future<AIRecognitionResult> parseText(String text) async {
    try {
      final qwenResult = await _qwenService.parseBookkeepingText(text);
      return AIRecognitionResult.fromQwenResult(qwenResult);
    } catch (e) {
      return AIRecognitionResult.error('文本解析失败: \$e');
    }
  }

  /// 智能分类建议
  /// 根据交易描述推荐最可能的分类，使用千问模型
  Future<String?> suggestCategory(String description) async {
    try {
      final category = await _qwenService.suggestCategory(description);
      if (category != null) {
        final mapped = AIRecognitionResult.categoryMap[category] ?? 
            category.toLowerCase();
        if (mapped == 'other') {
          return isIncomeType(description) ? 'other_income' : 'other_expense';
        }
        return mapped;
      }
      return localSuggestCategory(description);
    } catch (e) {
      return localSuggestCategory(description);
    }
  }


================================================================================
                              后30页源代码
                          （第31页 - 第60页）
================================================================================

================================================================================
                              第31页
================================================================================
  /// 邮箱账单解析
  /// 从信用卡账单邮件中提取多条交易记录
  Future<List<AIRecognitionResult>> parseEmailBill(String emailContent) async {
    try {
      final qwenResults = await _qwenService.parseEmailBill(emailContent);
      return qwenResults.map((r) => 
          AIRecognitionResult.fromQwenResult(r)).toList();
    } catch (e) {
      return [AIRecognitionResult.error('账单解析失败: $e')];
    }
  }

  /// 本地智能分类（离线模式）
  /// 使用关键词匹配进行分类推荐，优先返回二级分类
  String localSuggestCategory(String description) {
    final text = description.toLowerCase();

    // ========== 交通分类（优先级高）==========
    if (_containsAny(text, ['打车', '滴滴', '出租车', '高德打车', 
        'T3', '曹操', '首汽', '网约车', '快车', '专车'])) {
      return 'transport_taxi';
    }
    if (_containsAny(text, ['地铁', '公交', '公交卡', '地铁卡'])) {
      return 'transport_public';
    }
    if (_containsAny(text, ['高铁', '火车', '12306', '铁路', '动车'])) {
      return 'transport_train';
    }
    if (_containsAny(text, ['飞机', '机票', '航班', '航空'])) {
      return 'transport_flight';
    }
    if (_containsAny(text, ['加油', '中国石化', '中国石油', '壳牌'])) {
      return 'transport_fuel';
    }
    if (_containsAny(text, ['停车', '停车费', '停车场'])) {
      return 'transport_parking';
    }
    if (_containsAny(text, ['过路费', 'ETC', '高速', '哈啰', 
        '美团单车', '青桔', '共享单车', '车费', '路费', '交通'])) {
      return 'transport';
    }

    // ========== 餐饮分类 ==========
    if (_containsAny(text, ['早餐', '早饭', '早点', '包子', '豆浆'])) {
      return 'food_breakfast';
    }
    if (_containsAny(text, ['午餐', '午饭', '中餐', '工作餐'])) {
      return 'food_lunch';
    }

================================================================================
                              第32页
================================================================================
    if (_containsAny(text, ['晚餐', '晚饭', '夜宵', '宵夜'])) {
      return 'food_dinner';
    }
    if (_containsAny(text, ['咖啡', '星巴克', '瑞幸', 'Luckin', 
        '奶茶', '喜茶', '奈雪', '蜜雪', '茶百道', 'COCO', 
        '一点点', '饮料', '茶'])) {
      return 'food_drink';
    }
    if (_containsAny(text, ['外卖', '美团外卖', '饿了么'])) {
      return 'food_delivery';
    }
    if (_containsAny(text, ['水果', '苹果', '香蕉', '橙子', '果汁'])) {
      return 'food_fruit';
    }
    if (_containsAny(text, ['零食', '小吃', '糖果', '薯片', '饼干'])) {
      return 'food_snack';
    }
    if (_containsAny(text, ['饭', '菜', '餐', '吃', '喝', '麦当劳', 
        '肯德基', 'KFC', '必胜客', '汉堡王', '德克士',
        '海底捞', '火锅', '烧烤', '快餐', '便当', '面包', 
        '蛋糕', '烘焙', '甜品',
        '盒马', '永辉', '沃尔玛', '便利店', '全家', '711', 
        '罗森', '便利蜂'])) {
      return 'food';
    }

    // ========== 购物分类 ==========
    if (_containsAny(text, ['日用品', '牙膏', '洗发水', '纸巾', 
        '超市日用', '生活用品'])) {
      return 'shopping_daily';
    }
    if (_containsAny(text, ['手机', '电脑', '数码', '电子产品', 
        '耳机', '苹果', 'Apple', '小米', '华为'])) {
      return 'shopping_digital';
    }
    if (_containsAny(text, ['冰箱', '洗衣机', '空调', '电视', '家电'])) {
      return 'shopping_appliance';
    }
    if (_containsAny(text, ['家具', '床', '沙发', '桌子', '椅子', '宜家'])) {
      return 'shopping_furniture';
    }
    if (_containsAny(text, ['礼物', '礼品', '送人'])) {
      return 'shopping_gift';
    }
    if (_containsAny(text, ['淘宝', '天猫', '京东', '拼多多', 
        '唯品会', '苏宁', '国美',
        '超市', '商场', '百货', '购物', '网购', '买'])) {
      return 'shopping';
    }

================================================================================
                              第33页
================================================================================
    // ========== 娱乐分类 ==========
    if (_containsAny(text, ['电影', '猫眼', '淘票票', '万达影城', '影院'])) {
      return 'entertainment_movie';
    }
    if (_containsAny(text, ['游戏', '充值', '王者', '吃鸡', '原神'])) {
      return 'entertainment_game';
    }
    if (_containsAny(text, ['KTV', 'ktv', '唱歌', '卡拉OK'])) {
      return 'entertainment_ktv';
    }
    if (_containsAny(text, ['旅游', '景点', '门票', '酒店', 
        '迪士尼', '环球影城', '欢乐谷'])) {
      return 'entertainment_travel';
    }
    if (_containsAny(text, ['健身', 'Keep', '瑜伽', '游泳', '健身房'])) {
      return 'entertainment_fitness';
    }
    if (_containsAny(text, ['运动', '球场', '球馆'])) {
      return 'entertainment_sport';
    }
    if (_containsAny(text, ['聚会', '派对'])) {
      return 'entertainment_party';
    }
    if (_containsAny(text, ['演唱会', '演出', '话剧', '展览', 
        '娱乐', '休闲'])) {
      return 'entertainment';
    }

    // ========== 会员订阅 ==========
    if (_containsAny(text, ['爱奇艺', '腾讯视频', '优酷', 'B站', 
        'Netflix', '视频会员'])) {
      return 'subscription_video';
    }
    if (_containsAny(text, ['网易云', 'QQ音乐', 'Spotify', '音乐会员'])) {
      return 'subscription_music';
    }
    if (_containsAny(text, ['百度网盘', 'iCloud', '网盘'])) {
      return 'subscription_cloud';
    }
    if (_containsAny(text, ['88VIP', '京东Plus', '购物会员'])) {
      return 'subscription_shopping';
    }
    if (_containsAny(text, ['会员', 'VIP'])) {
      return 'subscription';
    }

    // ========== 居住分类 ==========
    if (_containsAny(text, ['房租', '租金', '月租'])) {
      return 'housing_rent';
    }

================================================================================
                              第34页
================================================================================
    if (_containsAny(text, ['房贷', '按揭', '还贷'])) {
      return 'housing_mortgage';
    }
    if (_containsAny(text, ['物业', '物业费'])) {
      return 'housing_property';
    }
    if (_containsAny(text, ['维修', '修理', '装修'])) {
      return 'housing_repair';
    }
    if (_containsAny(text, ['押金'])) {
      return 'housing';
    }

    // ========== 水电燃气 ==========
    if (_containsAny(text, ['电费', '充电费'])) {
      return 'utilities_electric';
    }
    if (_containsAny(text, ['水费'])) {
      return 'utilities_water';
    }
    if (_containsAny(text, ['燃气', '天然气', '煤气'])) {
      return 'utilities_gas';
    }
    if (_containsAny(text, ['暖气', '供暖'])) {
      return 'utilities_heating';
    }
    if (_containsAny(text, ['水电'])) {
      return 'utilities';
    }

    // ========== 通讯 ==========
    if (_containsAny(text, ['话费', '手机费', '充值'])) {
      return 'communication_phone';
    }
    if (_containsAny(text, ['网费', '宽带', '中国移动', 
        '中国联通', '中国电信'])) {
      return 'communication_internet';
    }

    // ========== 医疗分类 ==========
    if (_containsAny(text, ['挂号', '门诊', '看病'])) {
      return 'medical_clinic';
    }
    if (_containsAny(text, ['药', '药店', '大参林', '益丰', 
        '老百姓', '买药'])) {
      return 'medical_medicine';
    }
    if (_containsAny(text, ['住院'])) {
      return 'medical_hospital';
    }
    if (_containsAny(text, ['体检', '美年', '爱康', '健康检查'])) {
      return 'medical_checkup';
    }

================================================================================
                              第35页
================================================================================
    if (_containsAny(text, ['保健品', '维生素'])) {
      return 'medical_supplement';
    }
    if (_containsAny(text, ['医院', '就医', '治疗', '牙科', 
        '口腔', '眼科', '医疗', '健康'])) {
      return 'medical';
    }

    // ========== 教育分类 ==========
    if (_containsAny(text, ['学费', '报名费'])) {
      return 'education_tuition';
    }
    if (_containsAny(text, ['书', '图书', '书店', '买书'])) {
      return 'education_books';
    }
    if (_containsAny(text, ['培训', '课程', '网课', '新东方', 
        '学而思', '猿辅导', '作业帮'])) {
      return 'education_training';
    }
    if (_containsAny(text, ['考试', '报名'])) {
      return 'education_exam';
    }
    if (_containsAny(text, ['教育', '学习', '补习', '辅导', 
        '文具', '笔记本'])) {
      return 'education';
    }

    // ========== 服饰分类 ==========
    if (_containsAny(text, ['衣服', '上衣', '裤子', '外套', 
        '服装', '优衣库', 'ZARA', 'HM', 'GAP'])) {
      return 'clothing_clothes';
    }
    if (_containsAny(text, ['鞋子', '运动鞋', '皮鞋', '鞋'])) {
      return 'clothing_shoes';
    }
    if (_containsAny(text, ['配饰', '手表', '项链', '包', '帽子'])) {
      return 'clothing_accessories';
    }

    // ========== 美容分类 ==========
    if (_containsAny(text, ['护肤', '面膜', '水乳', '护肤品'])) {
      return 'beauty_skincare';
    }
    if (_containsAny(text, ['化妆品', '口红', '粉底', 
        '丝芙兰', '屈臣氏'])) {
      return 'beauty_cosmetics';
    }
    if (_containsAny(text, ['理发', '美发', '剪头发'])) {
      return 'beauty_haircut';
    }
    if (_containsAny(text, ['美甲', '指甲'])) {
      return 'beauty_nails';
    }

================================================================================
                              第36页
================================================================================
    // ========== 人情往来 ==========
    if (_containsAny(text, ['份子钱', '随份子', '红包钱'])) {
      return 'social_gift_money';
    }
    if (_containsAny(text, ['送礼', '过节'])) {
      return 'social_festival';
    }
    if (_containsAny(text, ['请客', '请吃饭'])) {
      return 'social_treat';
    }
    if (_containsAny(text, ['发红包'])) {
      return 'social_redpacket';
    }
    if (_containsAny(text, ['给父母', '孝敬'])) {
      return 'social_elder';
    }

    // ========== 金融保险 ==========
    if (_containsAny(text, ['人寿', '寿险'])) {
      return 'finance_life_insurance';
    }
    if (_containsAny(text, ['医保', '医疗险'])) {
      return 'finance_medical_insurance';
    }
    if (_containsAny(text, ['车险', '交强险'])) {
      return 'finance_car_insurance';
    }
    if (_containsAny(text, ['手续费', '转账费'])) {
      return 'finance_fee';
    }
    if (_containsAny(text, ['利息', '贷款利息'])) {
      return 'finance_loan_interest';
    }

    // ========== 宠物 ==========
    if (_containsAny(text, ['猫粮', '狗粮', '宠物食品'])) {
      return 'pet_food';
    }
    if (_containsAny(text, ['猫砂', '宠物玩具', '宠物用品'])) {
      return 'pet_supplies';
    }
    if (_containsAny(text, ['宠物医院', '宠物看病'])) {
      return 'pet_medical';
    }

    // ========== 收入分类 ==========
    if (_containsAny(text, ['基本工资', '底薪'])) {
      return 'salary_base';
    }
    if (_containsAny(text, ['绩效', '绩效奖'])) {
      return 'salary_performance';
    }
    if (_containsAny(text, ['加班费', '加班工资'])) {
      return 'salary_overtime';
    }

================================================================================
                              第37页
================================================================================
    if (_containsAny(text, ['年终奖', '十三薪'])) {
      return 'salary_annual';
    }
    if (_containsAny(text, ['工资', '薪水', '月薪', '发工资', '薪资'])) {
      return 'salary';
    }
    if (_containsAny(text, ['项目奖', '完成奖'])) {
      return 'bonus_project';
    }
    if (_containsAny(text, ['季度奖'])) {
      return 'bonus_quarterly';
    }
    if (_containsAny(text, ['奖金', '提成'])) {
      return 'bonus';
    }
    if (_containsAny(text, ['兼职', '副业', '外快', '私单'])) {
      return 'parttime';
    }
    if (_containsAny(text, ['理财', '投资', '收益', '分红', 
        '股票', '基金', '余额宝'])) {
      return 'investment';
    }
    if (_containsAny(text, ['收红包', '微信红包'])) {
      return 'redpacket';
    }
    if (_containsAny(text, ['报销', '公司报销'])) {
      return 'reimburse';
    }
    if (_containsAny(text, ['生意', '店铺', '营业', '经营'])) {
      return 'business';
    }
    if (_containsAny(text, ['收入', '到账', '进账', '返现', '收到'])) {
      return 'other_income';
    }

    return 'other_expense';  // 默认为支出的其他分类
  }

  /// 判断是否是收入类型
  bool isIncomeType(String description) {
    final text = description.toLowerCase();
    return _containsAny(text, ['工资', '薪水', '奖金', '红包', 
        '收入', '到账', '进账', '报销', '利息', '返现', '收到', '赚']);
  }

  bool _containsAny(String text, List<String> keywords) {
    for (final keyword in keywords) {
      if (text.contains(keyword)) {
        return true;
      }
    }
    return false;
  }
}


================================================================================
                              第38页
================================================================================
// 文件: app/lib/services/database_service.dart
// 数据库服务 - SQLite本地数据库管理

import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import '../models/transaction.dart' as model;
import '../models/transaction_split.dart';
import '../models/account.dart';
import '../models/category.dart';
import '../models/ledger.dart';
import '../models/budget.dart';
import '../models/template.dart';
import '../models/recurring_transaction.dart';
import '../models/credit_card.dart';
import '../models/savings_goal.dart' as savings;
import '../models/bill_reminder.dart';
import '../models/investment_account.dart';
import '../models/debt.dart';
import '../models/member.dart';
import '../models/import_batch.dart';
import '../models/resource_pool.dart';
import '../models/budget_vault.dart';
import 'package:flutter/material.dart';
import 'database_migration_service.dart';
import '../core/logger.dart';

class DatabaseService {
  static final DatabaseService _instance = DatabaseService._internal();
  static Database? _database;
  final DatabaseMigrationService _migrationService = 
      DatabaseMigrationService();
  final Logger _logger = Logger();

  // 当前数据库版本
  static const int currentVersion = 15;

  factory DatabaseService() => _instance;

  DatabaseService._internal();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }

  Future<Database> _initDatabase() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'ai_bookkeeping.db');

================================================================================
                              第39页
================================================================================
    // 检查是否需要迁移并创建备份
    int? existingVersion;
    try {
      final db = await openDatabase(path, readOnly: true);
      existingVersion = await db.getVersion();
      await db.close();
    } catch (e) {
      // 数据库不存在或损坏，将创建新数据库
      _logger.debug('No existing database found', tag: 'DB');
    }

    // 如果需要升级，先创建备份
    if (existingVersion != null && existingVersion < currentVersion) {
      final result = await _migrationService.prepareMigration(
        currentVersion: existingVersion,
        targetVersion: currentVersion,
      );
      if (!result.isSuccess) {
        _logger.warning('Migration preparation failed', tag: 'DB');
      }
    }

    return await openDatabase(
      path,
      version: currentVersion,
      onCreate: _onCreate,
      onUpgrade: _onUpgradeWithRecovery,
    );
  }

  /// 带恢复能力的升级方法
  Future<void> _onUpgradeWithRecovery(Database db, int oldVersion, 
      int newVersion) async {
    try {
      await _onUpgrade(db, oldVersion, newVersion);

      // 迁移成功
      await _migrationService.onMigrationComplete(
        newVersion: newVersion,
        success: true,
      );
    } catch (e) {
      // 迁移失败
      await _migrationService.onMigrationComplete(
        newVersion: newVersion,
        success: false,
        error: e.toString(),
      );

      _logger.error('Database migration failed: $e', tag: 'DB');
      rethrow;
    }
  }

================================================================================
                              第40页
================================================================================
  Future<void> _onCreate(Database db, int version) async {
    // Transactions table
    await db.execute('''
      CREATE TABLE transactions (
        id TEXT PRIMARY KEY,
        type INTEGER NOT NULL,
        amount REAL NOT NULL,
        category TEXT NOT NULL,
        note TEXT,
        date INTEGER NOT NULL,
        accountId TEXT NOT NULL,
        toAccountId TEXT,
        ledgerId TEXT NOT NULL DEFAULT 'default',
        isSplit INTEGER NOT NULL DEFAULT 0,
        isReimbursable INTEGER NOT NULL DEFAULT 0,
        isReimbursed INTEGER NOT NULL DEFAULT 0,
        tags TEXT,
        createdAt INTEGER NOT NULL,
        source INTEGER NOT NULL DEFAULT 0,
        aiConfidence REAL,
        sourceFileLocalPath TEXT,
        sourceFileServerUrl TEXT,
        sourceFileType TEXT,
        sourceFileSize INTEGER,
        recognitionRawData TEXT,
        sourceFileExpiresAt INTEGER,
        externalId TEXT,
        externalSource INTEGER,
        importBatchId TEXT,
        rawMerchant TEXT,
        vaultId TEXT,
        moneyAge INTEGER,
        locationJson TEXT
      )
    ''');

    // Import batches table
    await db.execute('''
      CREATE TABLE import_batches (
        id TEXT PRIMARY KEY,
        fileName TEXT NOT NULL,
        fileFormat TEXT NOT NULL,
        totalCount INTEGER NOT NULL,
        importedCount INTEGER NOT NULL,
        skippedCount INTEGER NOT NULL,
        failedCount INTEGER NOT NULL DEFAULT 0,
        totalExpense REAL DEFAULT 0,
        totalIncome REAL DEFAULT 0,
        dateRangeStart INTEGER,
        dateRangeEnd INTEGER,
        createdAt INTEGER NOT NULL,
        status INTEGER NOT NULL DEFAULT 0,
        revokedAt INTEGER,
        errorLog TEXT
      )
    ''');

================================================================================
                              第41页
================================================================================
    // Create indexes for import deduplication
    await db.execute(
        'CREATE INDEX idx_transactions_external ON '
        'transactions(externalId, externalSource)');
    await db.execute(
        'CREATE INDEX idx_transactions_import_batch ON '
        'transactions(importBatchId)');
    await db.execute(
        'CREATE INDEX idx_transactions_dedup ON '
        'transactions(date, amount, type, category)');
    await db.execute(
        'CREATE INDEX idx_import_batches_status ON '
        'import_batches(status)');

    // Transaction splits table
    await db.execute('''
      CREATE TABLE transaction_splits (
        id TEXT PRIMARY KEY,
        transactionId TEXT NOT NULL,
        category TEXT NOT NULL,
        subcategory TEXT,
        amount REAL NOT NULL,
        note TEXT,
        FOREIGN KEY (transactionId) REFERENCES transactions (id) 
            ON DELETE CASCADE
      )
    ''');

    // Accounts table
    await db.execute('''
      CREATE TABLE accounts (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        type INTEGER NOT NULL,
        balance REAL NOT NULL,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        isDefault INTEGER NOT NULL DEFAULT 0,
        createdAt INTEGER NOT NULL
      )
    ''');

    // Categories table
    await db.execute('''
      CREATE TABLE categories (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        isExpense INTEGER NOT NULL,
        parentId TEXT,
        sortOrder INTEGER NOT NULL DEFAULT 0,
        isCustom INTEGER NOT NULL DEFAULT 0
      )
    ''');

================================================================================
                              第42页
================================================================================
    // Ledgers table
    await db.execute('''
      CREATE TABLE ledgers (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        isDefault INTEGER NOT NULL DEFAULT 0,
        createdAt INTEGER NOT NULL
      )
    ''');

    // Budgets table
    await db.execute('''
      CREATE TABLE budgets (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        amount REAL NOT NULL,
        period INTEGER NOT NULL,
        categoryId TEXT,
        ledgerId TEXT NOT NULL,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        isEnabled INTEGER NOT NULL DEFAULT 1,
        createdAt INTEGER NOT NULL,
        budgetType INTEGER NOT NULL DEFAULT 0,
        enableCarryover INTEGER NOT NULL DEFAULT 0,
        carryoverSurplusOnly INTEGER NOT NULL DEFAULT 1
      )
    ''');

    // Budget carryover records table
    await db.execute('''
      CREATE TABLE budget_carryovers (
        id TEXT PRIMARY KEY,
        budgetId TEXT NOT NULL,
        year INTEGER NOT NULL,
        month INTEGER NOT NULL,
        carryoverAmount REAL NOT NULL,
        createdAt INTEGER NOT NULL,
        FOREIGN KEY (budgetId) REFERENCES budgets (id) ON DELETE CASCADE
      )
    ''');

    // Zero-based budget allocations table
    await db.execute('''
      CREATE TABLE zero_based_allocations (
        id TEXT PRIMARY KEY,
        budgetId TEXT NOT NULL,
        allocatedAmount REAL NOT NULL,
        year INTEGER NOT NULL,
        month INTEGER NOT NULL,
        createdAt INTEGER NOT NULL,
        FOREIGN KEY (budgetId) REFERENCES budgets (id) ON DELETE CASCADE
      )
    ''');

================================================================================
                              第43页
================================================================================
    // Templates table
    await db.execute('''
      CREATE TABLE templates (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        type INTEGER NOT NULL,
        amount REAL,
        category TEXT NOT NULL,
        note TEXT,
        accountId TEXT NOT NULL,
        toAccountId TEXT,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        useCount INTEGER NOT NULL DEFAULT 0,
        createdAt INTEGER NOT NULL,
        lastUsedAt INTEGER
      )
    ''');

    // Recurring transactions table
    await db.execute('''
      CREATE TABLE recurring_transactions (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        type INTEGER NOT NULL,
        amount REAL NOT NULL,
        category TEXT NOT NULL,
        note TEXT,
        accountId TEXT NOT NULL,
        toAccountId TEXT,
        frequency INTEGER NOT NULL,
        dayOfWeek INTEGER NOT NULL DEFAULT 1,
        dayOfMonth INTEGER NOT NULL DEFAULT 1,
        monthOfYear INTEGER NOT NULL DEFAULT 1,
        startDate INTEGER NOT NULL,
        endDate INTEGER,
        isEnabled INTEGER NOT NULL DEFAULT 1,
        lastExecutedAt INTEGER,
        nextExecuteAt INTEGER,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        createdAt INTEGER NOT NULL
      )
    ''');

    // Credit cards table
    await db.execute('''
      CREATE TABLE credit_cards (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        creditLimit REAL NOT NULL,
        usedAmount REAL NOT NULL DEFAULT 0,
        billDay INTEGER NOT NULL,
        paymentDueDay INTEGER NOT NULL,
        currentBill REAL NOT NULL DEFAULT 0,
        minPayment REAL NOT NULL DEFAULT 0,

================================================================================
                              第44页
================================================================================
        lastBillDate INTEGER,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        bankName TEXT,
        cardNumber TEXT,
        isEnabled INTEGER NOT NULL DEFAULT 1,
        createdAt INTEGER NOT NULL
      )
    ''');

    // Savings goals table
    await db.execute('''
      CREATE TABLE savings_goals (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        type INTEGER NOT NULL,
        targetAmount REAL NOT NULL,
        currentAmount REAL NOT NULL DEFAULT 0,
        startDate INTEGER NOT NULL,
        targetDate INTEGER,
        linkedAccountId TEXT,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        isCompleted INTEGER NOT NULL DEFAULT 0,
        completedAt INTEGER,
        isArchived INTEGER NOT NULL DEFAULT 0,
        createdAt INTEGER NOT NULL,
        linkedCategoryId TEXT,
        monthlyExpenseLimit REAL,
        recurringFrequency INTEGER,
        recurringAmount REAL,
        nextDepositDate INTEGER,
        enableReminder INTEGER NOT NULL DEFAULT 0
      )
    ''');

    // Savings deposits table
    await db.execute('''
      CREATE TABLE savings_deposits (
        id TEXT PRIMARY KEY,
        goalId TEXT NOT NULL,
        amount REAL NOT NULL,
        note TEXT,
        date INTEGER NOT NULL,
        createdAt INTEGER NOT NULL,
        FOREIGN KEY (goalId) REFERENCES savings_goals (id) ON DELETE CASCADE
      )
    ''');

    // Bill reminders table
    await db.execute('''
      CREATE TABLE bill_reminders (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        type INTEGER NOT NULL,

================================================================================
                              第45页
================================================================================
        amount REAL NOT NULL,
        frequency INTEGER NOT NULL,
        dayOfMonth INTEGER NOT NULL DEFAULT 1,
        dayOfWeek INTEGER,
        specificDate INTEGER,
        reminderDaysBefore INTEGER NOT NULL DEFAULT 3,
        reminderTimeHour INTEGER NOT NULL DEFAULT 9,
        reminderTimeMinute INTEGER NOT NULL DEFAULT 0,
        linkedAccountId TEXT,
        note TEXT,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        isEnabled INTEGER NOT NULL DEFAULT 1,
        lastRemindedAt INTEGER,
        nextReminderDate INTEGER,
        createdAt INTEGER NOT NULL
      )
    ''');

    // Investment accounts table
    await db.execute('''
      CREATE TABLE investment_accounts (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        type INTEGER NOT NULL,
        principal REAL NOT NULL DEFAULT 0,
        currentValue REAL NOT NULL DEFAULT 0,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        platform TEXT,
        accountNumber TEXT,
        isEnabled INTEGER NOT NULL DEFAULT 1,
        createdAt INTEGER NOT NULL
      )
    ''');

    // Investment records table
    await db.execute('''
      CREATE TABLE investment_records (
        id TEXT PRIMARY KEY,
        accountId TEXT NOT NULL,
        type INTEGER NOT NULL,
        amount REAL NOT NULL,
        date INTEGER NOT NULL,
        note TEXT,
        createdAt INTEGER NOT NULL,
        FOREIGN KEY (accountId) REFERENCES investment_accounts (id) 
            ON DELETE CASCADE
      )
    ''');

    // Debts table
    await db.execute('''
      CREATE TABLE debts (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,

================================================================================
                              第46页
================================================================================
        type INTEGER NOT NULL,
        totalAmount REAL NOT NULL,
        remainingAmount REAL NOT NULL,
        interestRate REAL NOT NULL DEFAULT 0,
        startDate INTEGER NOT NULL,
        dueDate INTEGER,
        linkedAccountId TEXT,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        isCompleted INTEGER NOT NULL DEFAULT 0,
        completedAt INTEGER,
        note TEXT,
        createdAt INTEGER NOT NULL
      )
    ''');

    // Debt payments table
    await db.execute('''
      CREATE TABLE debt_payments (
        id TEXT PRIMARY KEY,
        debtId TEXT NOT NULL,
        amount REAL NOT NULL,
        date INTEGER NOT NULL,
        note TEXT,
        createdAt INTEGER NOT NULL,
        FOREIGN KEY (debtId) REFERENCES debts (id) ON DELETE CASCADE
      )
    ''');

    // Members table (for family ledger)
    await db.execute('''
      CREATE TABLE members (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        avatarUrl TEXT,
        role INTEGER NOT NULL DEFAULT 0,
        ledgerId TEXT NOT NULL,
        userId TEXT,
        isActive INTEGER NOT NULL DEFAULT 1,
        createdAt INTEGER NOT NULL
      )
    ''');

    // Budget vaults table (零基预算小金库)
    await db.execute('''
      CREATE TABLE budget_vaults (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        type INTEGER NOT NULL,
        targetAmount REAL NOT NULL,
        allocatedAmount REAL NOT NULL DEFAULT 0,
        spentAmount REAL NOT NULL DEFAULT 0,

================================================================================
                              第47页
================================================================================
        dueDate INTEGER,
        isRecurring INTEGER NOT NULL DEFAULT 0,
        recurrenceJson TEXT,
        linkedCategoryId TEXT,
        linkedCategoryIds TEXT,
        ledgerId TEXT NOT NULL,
        isEnabled INTEGER NOT NULL DEFAULT 1,
        sortOrder INTEGER NOT NULL DEFAULT 0,
        createdAt INTEGER NOT NULL,
        updatedAt INTEGER NOT NULL,
        allocationType INTEGER NOT NULL DEFAULT 0,
        targetAllocation REAL,
        targetPercentage REAL
      )
    ''');

    // Vault allocations table (小金库分配记录)
    await db.execute('''
      CREATE TABLE vault_allocations (
        id TEXT PRIMARY KEY,
        vaultId TEXT NOT NULL,
        incomeTransactionId TEXT,
        amount REAL NOT NULL,
        note TEXT,
        allocatedAt INTEGER NOT NULL,
        FOREIGN KEY (vaultId) REFERENCES budget_vaults (id) ON DELETE CASCADE
      )
    ''');

    // Vault transfers table (小金库调拨记录)
    await db.execute('''
      CREATE TABLE vault_transfers (
        id TEXT PRIMARY KEY,
        fromVaultId TEXT NOT NULL,
        toVaultId TEXT NOT NULL,
        amount REAL NOT NULL,
        note TEXT,
        transferredAt INTEGER NOT NULL
      )
    ''');

    // Resource pools table (资源池)
    await db.execute('''
      CREATE TABLE resource_pools (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        iconCode INTEGER NOT NULL,
        colorValue INTEGER NOT NULL,
        totalAmount REAL NOT NULL DEFAULT 0,
        allocatedAmount REAL NOT NULL DEFAULT 0,
        ledgerId TEXT NOT NULL,
        isEnabled INTEGER NOT NULL DEFAULT 1,
        createdAt INTEGER NOT NULL
      )
    ''');

================================================================================
                              第48页
================================================================================
    // Create default ledger
    await db.insert('ledgers', {
      'id': 'default',
      'name': '默认账本',
      'description': '系统默认账本',
      'iconCode': Icons.book.codePoint,
      'colorValue': Colors.blue.toARGB32(),
      'isDefault': 1,
      'createdAt': DateTime.now().millisecondsSinceEpoch,
    });

    // Create default account
    await db.insert('accounts', {
      'id': 'default_cash',
      'name': '现金',
      'type': 0,
      'balance': 0.0,
      'iconCode': Icons.account_balance_wallet.codePoint,
      'colorValue': Colors.green.toARGB32(),
      'isDefault': 1,
      'createdAt': DateTime.now().millisecondsSinceEpoch,
    });
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    _logger.info('Upgrading database from v$oldVersion to v$newVersion', 
        tag: 'DB');

    // Version 2: Add source file fields to transactions
    if (oldVersion < 2) {
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN source INTEGER DEFAULT 0');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN aiConfidence REAL');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN sourceFileLocalPath TEXT');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN sourceFileServerUrl TEXT');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN sourceFileType TEXT');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN sourceFileSize INTEGER');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN recognitionRawData TEXT');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN sourceFileExpiresAt INTEGER');
    }

    // Version 3: Add batch import fields
    if (oldVersion < 3) {
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN externalId TEXT');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN externalSource INTEGER');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN importBatchId TEXT');
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN rawMerchant TEXT');

================================================================================
                              第49页
================================================================================
      // Create import_batches table
      await db.execute('''
        CREATE TABLE IF NOT EXISTS import_batches (
          id TEXT PRIMARY KEY,
          fileName TEXT NOT NULL,
          fileFormat TEXT NOT NULL,
          totalCount INTEGER NOT NULL,
          importedCount INTEGER NOT NULL,
          skippedCount INTEGER NOT NULL,
          failedCount INTEGER NOT NULL DEFAULT 0,
          totalExpense REAL DEFAULT 0,
          totalIncome REAL DEFAULT 0,
          dateRangeStart INTEGER,
          dateRangeEnd INTEGER,
          createdAt INTEGER NOT NULL,
          status INTEGER NOT NULL DEFAULT 0,
          revokedAt INTEGER,
          errorLog TEXT
        )
      ''');

      // Create indexes
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_transactions_external ON '
          'transactions(externalId, externalSource)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_transactions_import_batch ON '
          'transactions(importBatchId)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_transactions_dedup ON '
          'transactions(date, amount, type, category)');
      await db.execute(
          'CREATE INDEX IF NOT EXISTS idx_import_batches_status ON '
          'import_batches(status)');
    }

    // Version 4-14: Additional migrations...
    // (省略中间版本的迁移代码)

    // Version 15: Add budget vaults (零基预算小金库)
    if (oldVersion < 15) {
      await db.execute('''
        CREATE TABLE IF NOT EXISTS budget_vaults (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          description TEXT,
          iconCode INTEGER NOT NULL,
          colorValue INTEGER NOT NULL,
          type INTEGER NOT NULL,
          targetAmount REAL NOT NULL,
          allocatedAmount REAL NOT NULL DEFAULT 0,
          spentAmount REAL NOT NULL DEFAULT 0,
          dueDate INTEGER,
          isRecurring INTEGER NOT NULL DEFAULT 0,
          recurrenceJson TEXT,

================================================================================
                              第50页
================================================================================
          linkedCategoryId TEXT,
          linkedCategoryIds TEXT,
          ledgerId TEXT NOT NULL,
          isEnabled INTEGER NOT NULL DEFAULT 1,
          sortOrder INTEGER NOT NULL DEFAULT 0,
          createdAt INTEGER NOT NULL,
          updatedAt INTEGER NOT NULL,
          allocationType INTEGER NOT NULL DEFAULT 0,
          targetAllocation REAL,
          targetPercentage REAL
        )
      ''');

      await db.execute('''
        CREATE TABLE IF NOT EXISTS vault_allocations (
          id TEXT PRIMARY KEY,
          vaultId TEXT NOT NULL,
          incomeTransactionId TEXT,
          amount REAL NOT NULL,
          note TEXT,
          allocatedAt INTEGER NOT NULL,
          FOREIGN KEY (vaultId) REFERENCES budget_vaults (id) 
              ON DELETE CASCADE
        )
      ''');

      await db.execute('''
        CREATE TABLE IF NOT EXISTS vault_transfers (
          id TEXT PRIMARY KEY,
          fromVaultId TEXT NOT NULL,
          toVaultId TEXT NOT NULL,
          amount REAL NOT NULL,
          note TEXT,
          transferredAt INTEGER NOT NULL
        )
      ''');

      // Add vaultId to transactions
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN vaultId TEXT');
      
      // Add moneyAge to transactions
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN moneyAge INTEGER');
      
      // Add locationJson to transactions
      await db.execute(
          'ALTER TABLE transactions ADD COLUMN locationJson TEXT');
    }

    _logger.info('Database upgrade completed', tag: 'DB');
  }

  // ==================== Transaction CRUD ====================

  /// 插入交易记录
  Future<void> insertTransaction(model.Transaction transaction) async {
    final db = await database;
    await db.insert('transactions', transaction.toMap());
  }


================================================================================
                              第51页
================================================================================
  /// 更新交易记录
  Future<void> updateTransaction(model.Transaction transaction) async {
    final db = await database;
    await db.update(
      'transactions',
      transaction.toMap(),
      where: 'id = ?',
      whereArgs: [transaction.id],
    );
  }

  /// 删除交易记录
  Future<void> deleteTransaction(String id) async {
    final db = await database;
    await db.delete(
      'transactions',
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  /// 获取所有交易记录
  Future<List<model.Transaction>> getTransactions({
    String? ledgerId,
    DateTime? startDate,
    DateTime? endDate,
    model.TransactionType? type,
    String? category,
    String? accountId,
    int? limit,
    int? offset,
  }) async {
    final db = await database;
    
    String whereClause = '1=1';
    List<dynamic> whereArgs = [];

    if (ledgerId != null) {
      whereClause += ' AND ledgerId = ?';
      whereArgs.add(ledgerId);
    }
    if (startDate != null) {
      whereClause += ' AND date >= ?';
      whereArgs.add(startDate.millisecondsSinceEpoch);
    }
    if (endDate != null) {
      whereClause += ' AND date <= ?';
      whereArgs.add(endDate.millisecondsSinceEpoch);
    }
    if (type != null) {
      whereClause += ' AND type = ?';
      whereArgs.add(type.index);
    }

================================================================================
                              第52页
================================================================================
    if (category != null) {
      whereClause += ' AND category = ?';
      whereArgs.add(category);
    }
    if (accountId != null) {
      whereClause += ' AND (accountId = ? OR toAccountId = ?)';
      whereArgs.add(accountId);
      whereArgs.add(accountId);
    }

    final List<Map<String, dynamic>> maps = await db.query(
      'transactions',
      where: whereClause,
      whereArgs: whereArgs,
      orderBy: 'date DESC, createdAt DESC',
      limit: limit,
      offset: offset,
    );

    // Load splits for split transactions
    List<model.Transaction> transactions = [];
    for (final map in maps) {
      List<TransactionSplit>? splits;
      if (map['isSplit'] == 1) {
        final splitMaps = await db.query(
          'transaction_splits',
          where: 'transactionId = ?',
          whereArgs: [map['id']],
        );
        splits = splitMaps.map((m) => TransactionSplit.fromMap(m)).toList();
      }
      transactions.add(model.Transaction.fromMap(map, splits: splits));
    }

    return transactions;
  }

  /// 根据ID获取交易记录
  Future<model.Transaction?> getTransactionById(String id) async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'transactions',
      where: 'id = ?',
      whereArgs: [id],
    );

    if (maps.isEmpty) return null;

    final map = maps.first;
    List<TransactionSplit>? splits;
    if (map['isSplit'] == 1) {
      final splitMaps = await db.query(
        'transaction_splits',
        where: 'transactionId = ?',
        whereArgs: [id],
      );
      splits = splitMaps.map((m) => TransactionSplit.fromMap(m)).toList();
    }

    return model.Transaction.fromMap(map, splits: splits);
  }

================================================================================
                              第53页
================================================================================
  /// 获取交易统计
  Future<Map<String, double>> getTransactionStats({
    required String ledgerId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    final db = await database;

    final result = await db.rawQuery('''
      SELECT 
        SUM(CASE WHEN type = 0 THEN amount ELSE 0 END) as totalExpense,
        SUM(CASE WHEN type = 1 THEN amount ELSE 0 END) as totalIncome
      FROM transactions
      WHERE ledgerId = ? 
        AND date >= ? 
        AND date <= ?
    ''', [
      ledgerId,
      startDate.millisecondsSinceEpoch,
      endDate.millisecondsSinceEpoch,
    ]);

    if (result.isEmpty) {
      return {'totalExpense': 0.0, 'totalIncome': 0.0};
    }

    return {
      'totalExpense': (result.first['totalExpense'] as num?)?.toDouble() ?? 0.0,
      'totalIncome': (result.first['totalIncome'] as num?)?.toDouble() ?? 0.0,
    };
  }

  /// 获取分类统计
  Future<List<Map<String, dynamic>>> getCategoryStats({
    required String ledgerId,
    required DateTime startDate,
    required DateTime endDate,
    required bool isExpense,
  }) async {
    final db = await database;

    final result = await db.rawQuery('''
      SELECT 
        category,
        SUM(amount) as total,
        COUNT(*) as count
      FROM transactions
      WHERE ledgerId = ? 
        AND date >= ? 
        AND date <= ?
        AND type = ?
      GROUP BY category
      ORDER BY total DESC
    ''', [
      ledgerId,
      startDate.millisecondsSinceEpoch,
      endDate.millisecondsSinceEpoch,
      isExpense ? 0 : 1,
    ]);

    return result;
  }

================================================================================
                              第54页
================================================================================
  // ==================== Account CRUD ====================

  /// 插入账户
  Future<void> insertAccount(Account account) async {
    final db = await database;
    await db.insert('accounts', account.toMap());
  }

  /// 更新账户
  Future<void> updateAccount(Account account) async {
    final db = await database;
    await db.update(
      'accounts',
      account.toMap(),
      where: 'id = ?',
      whereArgs: [account.id],
    );
  }

  /// 删除账户
  Future<void> deleteAccount(String id) async {
    final db = await database;
    await db.delete(
      'accounts',
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  /// 获取所有账户
  Future<List<Account>> getAccounts() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'accounts',
      orderBy: 'isDefault DESC, createdAt ASC',
    );
    return maps.map((map) => Account.fromMap(map)).toList();
  }

  /// 更新账户余额
  Future<void> updateAccountBalance(String accountId, double amount) async {
    final db = await database;
    await db.rawUpdate('''
      UPDATE accounts 
      SET balance = balance + ? 
      WHERE id = ?
    ''', [amount, accountId]);
  }

  // ==================== Budget Vault CRUD ====================

  /// 插入小金库
  Future<void> insertVault(BudgetVault vault) async {
    final db = await database;
    await db.insert('budget_vaults', vault.toMap());
  }

================================================================================
                              第55页
================================================================================
  /// 更新小金库
  Future<void> updateVault(BudgetVault vault) async {
    final db = await database;
    await db.update(
      'budget_vaults',
      vault.toMap(),
      where: 'id = ?',
      whereArgs: [vault.id],
    );
  }

  /// 删除小金库
  Future<void> deleteVault(String id) async {
    final db = await database;
    await db.delete(
      'budget_vaults',
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  /// 获取所有小金库
  Future<List<BudgetVault>> getVaults({String? ledgerId}) async {
    final db = await database;
    
    String? where;
    List<dynamic>? whereArgs;
    
    if (ledgerId != null) {
      where = 'ledgerId = ?';
      whereArgs = [ledgerId];
    }

    final List<Map<String, dynamic>> maps = await db.query(
      'budget_vaults',
      where: where,
      whereArgs: whereArgs,
      orderBy: 'sortOrder ASC, createdAt ASC',
    );
    return maps.map((map) => BudgetVault.fromMap(map)).toList();
  }

  /// 更新小金库已分配金额
  Future<void> updateVaultAllocated(String vaultId, double amount) async {
    final db = await database;
    await db.rawUpdate('''
      UPDATE budget_vaults 
      SET allocatedAmount = allocatedAmount + ?,
          updatedAt = ?
      WHERE id = ?
    ''', [amount, DateTime.now().millisecondsSinceEpoch, vaultId]);
  }

  /// 更新小金库已花费金额
  Future<void> updateVaultSpent(String vaultId, double amount) async {
    final db = await database;
    await db.rawUpdate('''
      UPDATE budget_vaults 
      SET spentAmount = spentAmount + ?,
          updatedAt = ?
      WHERE id = ?
    ''', [amount, DateTime.now().millisecondsSinceEpoch, vaultId]);
  }

================================================================================
                              第56页
================================================================================
  /// 插入小金库分配记录
  Future<void> insertVaultAllocation(VaultAllocation allocation) async {
    final db = await database;
    await db.insert('vault_allocations', allocation.toMap());
  }

  /// 获取小金库分配记录
  Future<List<VaultAllocation>> getVaultAllocations(String vaultId) async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'vault_allocations',
      where: 'vaultId = ?',
      whereArgs: [vaultId],
      orderBy: 'allocatedAt DESC',
    );
    return maps.map((map) => VaultAllocation.fromMap(map)).toList();
  }

  /// 插入小金库调拨记录
  Future<void> insertVaultTransfer(VaultTransfer transfer) async {
    final db = await database;
    await db.insert('vault_transfers', transfer.toMap());
  }

  /// 获取小金库统计摘要
  Future<VaultSummary> getVaultSummary({String? ledgerId}) async {
    final vaults = await getVaults(ledgerId: ledgerId);
    
    if (vaults.isEmpty) {
      return VaultSummary.empty();
    }

    double totalAllocated = 0;
    double totalSpent = 0;
    int healthyCount = 0;
    int underfundedCount = 0;
    int almostEmptyCount = 0;
    int overSpentCount = 0;
    Map<VaultType, double> allocationByType = {};
    Map<VaultType, double> spentByType = {};

    for (final vault in vaults) {
      totalAllocated += vault.allocatedAmount;
      totalSpent += vault.spentAmount;

      allocationByType[vault.type] = 
          (allocationByType[vault.type] ?? 0) + vault.allocatedAmount;
      spentByType[vault.type] = 
          (spentByType[vault.type] ?? 0) + vault.spentAmount;

      switch (vault.status) {
        case VaultStatus.healthy:
          healthyCount++;
          break;
        case VaultStatus.underfunded:
          underfundedCount++;
          break;

================================================================================
                              第57页
================================================================================
        case VaultStatus.almostEmpty:
          almostEmptyCount++;
          break;
        case VaultStatus.overSpent:
          overSpentCount++;
          break;
      }
    }

    return VaultSummary(
      totalVaults: vaults.length,
      totalAllocated: totalAllocated,
      totalSpent: totalSpent,
      totalAvailable: totalAllocated - totalSpent,
      healthyCount: healthyCount,
      underfundedCount: underfundedCount,
      almostEmptyCount: almostEmptyCount,
      overSpentCount: overSpentCount,
      allocationByType: allocationByType,
      spentByType: spentByType,
    );
  }

  // ==================== Import Batch CRUD ====================

  /// 插入导入批次
  Future<void> insertImportBatch(ImportBatch batch) async {
    final db = await database;
    await db.insert('import_batches', batch.toMap());
  }

  /// 更新导入批次
  Future<void> updateImportBatch(ImportBatch batch) async {
    final db = await database;
    await db.update(
      'import_batches',
      batch.toMap(),
      where: 'id = ?',
      whereArgs: [batch.id],
    );
  }

  /// 获取导入批次列表
  Future<List<ImportBatch>> getImportBatches({int? limit}) async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'import_batches',
      orderBy: 'createdAt DESC',
      limit: limit,
    );
    return maps.map((map) => ImportBatch.fromMap(map)).toList();
  }

  /// 撤销导入批次
  Future<void> revokeImportBatch(String batchId) async {
    final db = await database;
    
    // 删除该批次的所有交易
    await db.delete(
      'transactions',
      where: 'importBatchId = ?',
      whereArgs: [batchId],
    );

================================================================================
                              第58页
================================================================================
    // 更新批次状态
    await db.update(
      'import_batches',
      {
        'status': 2, // revoked
        'revokedAt': DateTime.now().millisecondsSinceEpoch,
      },
      where: 'id = ?',
      whereArgs: [batchId],
    );
  }

  /// 检查重复交易
  Future<bool> checkDuplicateTransaction({
    required DateTime date,
    required double amount,
    required int type,
    String? externalId,
    int? externalSource,
  }) async {
    final db = await database;

    // 如果有外部ID，优先检查外部ID
    if (externalId != null && externalSource != null) {
      final result = await db.query(
        'transactions',
        where: 'externalId = ? AND externalSource = ?',
        whereArgs: [externalId, externalSource],
        limit: 1,
      );
      if (result.isNotEmpty) return true;
    }

    // 检查相同日期、金额、类型的交易
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    final result = await db.query(
      'transactions',
      where: 'date >= ? AND date < ? AND amount = ? AND type = ?',
      whereArgs: [
        startOfDay.millisecondsSinceEpoch,
        endOfDay.millisecondsSinceEpoch,
        amount,
        type,
      ],
      limit: 1,
    );

    return result.isNotEmpty;
  }

  /// 关闭数据库
  Future<void> close() async {
    if (_database != null) {
      await _database!.close();
      _database = null;
    }
  }
}

================================================================================
                              第59页
================================================================================
// 文件: app/lib/services/money_age_service.dart
// 钱龄计算服务

import '../models/transaction.dart';
import 'database_service.dart';

/// 钱龄服务
/// 
/// 钱龄是指从收入到支出的时间间隔（天数）。
/// 钱龄越长，说明消费越理性，储蓄习惯越好。
class MoneyAgeService {
  static final MoneyAgeService _instance = MoneyAgeService._internal();
  final DatabaseService _db = DatabaseService();

  factory MoneyAgeService() => _instance;

  MoneyAgeService._internal();

  /// 计算支出的钱龄
  /// 
  /// 使用FIFO（先进先出）算法：
  /// 1. 获取所有未消费完的收入（按时间排序）
  /// 2. 从最早的收入开始扣减
  /// 3. 计算加权平均钱龄
  Future<int?> calculateMoneyAge({
    required double expenseAmount,
    required DateTime expenseDate,
    required String ledgerId,
    String? vaultId,
  }) async {
    // 获取该账本/小金库的所有收入记录
    final incomes = await _db.getTransactions(
      ledgerId: ledgerId,
      type: TransactionType.income,
      endDate: expenseDate,
    );

    if (incomes.isEmpty) {
      return null; // 没有收入记录，无法计算钱龄
    }

    // 按日期排序（FIFO）
    incomes.sort((a, b) => a.date.compareTo(b.date));

    // 计算每笔收入的剩余金额
    Map<String, double> incomeRemaining = {};
    for (final income in incomes) {
      incomeRemaining[income.id] = income.amount;
    }

    // 获取该日期之前的所有支出，扣减已消费的金额
    final expenses = await _db.getTransactions(
      ledgerId: ledgerId,
      type: TransactionType.expense,
      endDate: expenseDate.subtract(const Duration(seconds: 1)),
    );

================================================================================
                              第60页
================================================================================
    // 按FIFO扣减已消费金额
    for (final expense in expenses) {
      double remaining = expense.amount;
      for (final income in incomes) {
        if (remaining <= 0) break;
        final available = incomeRemaining[income.id] ?? 0;
        if (available > 0) {
          final deduct = remaining > available ? available : remaining;
          incomeRemaining[income.id] = available - deduct;
          remaining -= deduct;
        }
      }
    }

    // 计算本次支出的加权平均钱龄
    double totalWeightedAge = 0;
    double totalAmount = 0;
    double remaining = expenseAmount;

    for (final income in incomes) {
      if (remaining <= 0) break;
      final available = incomeRemaining[income.id] ?? 0;
      if (available > 0) {
        final consume = remaining > available ? available : remaining;
        final age = expenseDate.difference(income.date).inDays;
        totalWeightedAge += age * consume;
        totalAmount += consume;
        remaining -= consume;
      }
    }

    if (totalAmount <= 0) {
      return null; // 没有可用的收入来源
    }

    return (totalWeightedAge / totalAmount).round();
  }

  /// 获取钱龄统计
  Future<MoneyAgeStats> getMoneyAgeStats({
    required String ledgerId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    final expenses = await _db.getTransactions(
      ledgerId: ledgerId,
      type: TransactionType.expense,
      startDate: startDate,
      endDate: endDate,
    );

    final validExpenses = expenses.where((e) => e.moneyAge != null).toList();
    
    if (validExpenses.isEmpty) {
      return MoneyAgeStats.empty();
    }

    final ages = validExpenses.map((e) => e.moneyAge!).toList();
    ages.sort();

    return MoneyAgeStats(
      averageAge: ages.reduce((a, b) => a + b) / ages.length,
      medianAge: ages[ages.length ~/ 2].toDouble(),
      minAge: ages.first.toDouble(),
      maxAge: ages.last.toDouble(),
      totalTransactions: validExpenses.length,
    );
  }
}

/// 钱龄统计数据
class MoneyAgeStats {
  final double averageAge;
  final double medianAge;
  final double minAge;
  final double maxAge;
  final int totalTransactions;

  const MoneyAgeStats({
    required this.averageAge,
    required this.medianAge,
    required this.minAge,
    required this.maxAge,
    required this.totalTransactions,
  });

  factory MoneyAgeStats.empty() {
    return const MoneyAgeStats(
      averageAge: 0,
      medianAge: 0,
      minAge: 0,
      maxAge: 0,
      totalTransactions: 0,
    );
  }
}

================================================================================
                           源代码文档结束
================================================================================

说明：
1. 本文档包含前30页和后30页源代码，共60页
2. 每页约50行代码
3. 代码来源于智能AI记账管理系统V1.0的核心模块
4. 包含应用入口、数据模型、AI服务、数据库服务等核心代码

